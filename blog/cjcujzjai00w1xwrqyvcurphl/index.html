<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/blog/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/blog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/blog/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/blog/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="HTML," />










<meta name="description" content="颜 林, 软件工程师, IBM2009 年  12 月  10 日HTML5 引入了新的的网页元素：&amp;lt;canvas&amp;gt;。Canvas 是一片空白的绘图区域，网页开发者可以利用 JavaScript在该区域中自由地进行 2D 绘图。Canvas 可以用于渲染华丽的网页设计界面。本文通过一个详细的实例来说明如何用 Canvas来制作一个图片的浏览器。最终的效果可以达到 Flash 程序的效果">
<meta name="keywords" content="HTML">
<meta property="og:type" content="article">
<meta property="og:title" content="用 HTML Canvas 创建一个图片浏览器">
<meta property="og:url" content="https://vanessa.js.org/blog/cjcujzjai00w1xwrqyvcurphl/index.html">
<meta property="og:site_name" content="Vanessa">
<meta property="og:description" content="颜 林, 软件工程师, IBM2009 年  12 月  10 日HTML5 引入了新的的网页元素：&amp;lt;canvas&amp;gt;。Canvas 是一片空白的绘图区域，网页开发者可以利用 JavaScript在该区域中自由地进行 2D 绘图。Canvas 可以用于渲染华丽的网页设计界面。本文通过一个详细的实例来说明如何用 Canvas来制作一个图片的浏览器。最终的效果可以达到 Flash 程序的效果">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/v14/rules/blue_rule.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/v14/icons/u_bold.gif">
<meta property="og:image" content="http://www.ibm.com/developerworks/cn/web/0912_yanlin_htmlcanvas/image003.gif">
<meta property="og:image" content="http://www.ibm.com/i/v14/rules/blue_rule.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/v14/icons/u_bold.gif">
<meta property="og:image" content="http://www.ibm.com/developerworks/cn/web/0912_yanlin_htmlcanvas/image005.jpg">
<meta property="og:image" content="http://www.ibm.com/i/v14/rules/blue_rule.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/v14/icons/u_bold.gif">
<meta property="og:image" content="http://www.ibm.com/developerworks/cn/web/0912_yanlin_htmlcanvas/image007.gif">
<meta property="og:image" content="http://www.ibm.com/developerworks/cn/web/0912_yanlin_htmlcanvas/image009.jpg">
<meta property="og:image" content="http://www.ibm.com/developerworks/cn/web/0912_yanlin_htmlcanvas/image011.gif">
<meta property="og:image" content="http://www.ibm.com/developerworks/cn/web/0912_yanlin_htmlcanvas/image013.gif">
<meta property="og:image" content="http://www.ibm.com/i/v14/rules/blue_rule.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/v14/icons/u_bold.gif">
<meta property="og:image" content="http://www.ibm.com/developerworks/cn/web/0912_yanlin_htmlcanvas/image015.jpg">
<meta property="og:image" content="http://www.ibm.com/developerworks/cn/web/0912_yanlin_htmlcanvas/image017.jpg">
<meta property="og:image" content="http://www.ibm.com/i/v14/rules/blue_rule.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/v14/icons/u_bold.gif">
<meta property="og:image" content="http://www.ibm.com/i/v14/rules/blue_rule.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/v14/icons/u_bold.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/v14/icons/fw.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:updated_time" content="2018-01-25T01:51:10.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="用 HTML Canvas 创建一个图片浏览器">
<meta name="twitter:description" content="颜 林, 软件工程师, IBM2009 年  12 月  10 日HTML5 引入了新的的网页元素：&amp;lt;canvas&amp;gt;。Canvas 是一片空白的绘图区域，网页开发者可以利用 JavaScript在该区域中自由地进行 2D 绘图。Canvas 可以用于渲染华丽的网页设计界面。本文通过一个详细的实例来说明如何用 Canvas来制作一个图片的浏览器。最终的效果可以达到 Flash 程序的效果">
<meta name="twitter:image" content="http://www.ibm.com/i/c.gif">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://vanessa.js.org/blog/cjcujzjai00w1xwrqyvcurphl/"/>





  <title>用 HTML Canvas 创建一个图片浏览器 | Vanessa</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/blog/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Vanessa</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/blog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/blog/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://vanessa.js.org/blog/blog/cjcujzjai00w1xwrqyvcurphl/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Vanessa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vanessa">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">用 HTML Canvas 创建一个图片浏览器</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2009-12-22T09:23:00+08:00">
                2009-12-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <table style="width: 100%;" border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr valign="top"><br><td width="10" height="18"></td><br><td width="100%"></td><br><td class="no-print" width="192"></td><br></tr><br></tbody><br></table><br><table style="width: 100%;" border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr valign="top"><br><td width="10"><img src="http://www.ibm.com/i/c.gif" alt="" width="10" height="1"><br></td><br><td width="100%"><br><table class="no-print" style="width: 160px;" border="0" cellspacing="0" cellpadding="0" align="right"><br><tbody><br><tr><br><td width="10"></td><br><td><br><table style="width: 150px;" border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td class="v14-header-1-small"></td><br></tr><br></tbody><br></table><br><table class="v14-gray-table-border" border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td class="no-padding" width="150"></td><br></tr><br></tbody><br></table><br><!-- START RESERVED FOR FUTURE USE INCLUDE FILES--><!--  this content will be automatically generated across all content areas --><!-- END RESERVED FOR FUTURE USE INCLUDE FILES--><br><br></td><br></tr><br></tbody><br></table><br><p><a href="http://www.ibm.com/developerworks/cn/web/0912_yanlin_htmlcanvas/#author" target="_blank" rel="noopener">颜 林</a><br>, 软件工程师, IBM</p><br><p>2009 年  12 月  10 日</p><br><blockquote>HTML<br>5 引入了新的的网页元素：&lt;canvas&gt;。Canvas 是一片空白的绘图区域，网页开发者可以利用 JavaScript<br>在该区域中自由地进行 2D 绘图。Canvas 可以用于渲染华丽的网页设计界面。本文通过一个详细的实例来说明如何用 Canvas<br>来制作一个图片的浏览器。最终的效果可以达到 Flash 程序的效果。通过本文，读者可以了解如何使用 Canvas<br>的各种函数以及如何与用户事件进行交互，适合读者为 Web 设计和架构师。</blockquote><br><!-- START RESERVED FOR FUTURE USE INCLUDE FILES--><!--  include java script once we verify teams wants to use this and it will work on dbcs and cyrillic characters --><br><!-- END RESERVED FOR FUTURE USE INCLUDE FILES--><br><p><a name="major1"><span class="atitle">HTML Canvas 介绍</span><br></a><br></p><br><p>HTML5<br>是目前正在讨论的新一代 HTML 标准，它代表了现在 Web 领域的最新的发展方向。在 HTML5<br>标准中，加入了新的多样的内容描述标签，直接支持表单验证，视频和音频标签，网页元素的拖拽，离线存储，工作线程等等。当然，其中一个最令人激动的新特性<br>就是新的标签类型 Canvas，开发人员可以通过该标签，在网页上直接用脚本进行绘图，产生各种 2D 渲染的效果。所以有人预言，HTML5 将是<br>Flash 和 Silverlight 的&ldquo;杀手&rdquo;。从 Firefox 1.5 开始就已经支持 Canvas，Safari 也是很早就开始支持<br>Canvas。新的浏览器比如 Chrome 也是从一开始就支持。但遗憾的是，到目前为止，IE 一直不支持该标准。</p><br><p>下面内容<br>将通过如何用 Canvas 来制作一个图片浏览器的具体实例，来说明 Canvas 的各种 API，如何使用这些 API<br>以及如何应用到工程中去。本文将首先介绍如何创建图片浏览器的网页和 JavaScript 类，介绍整体界面的设计，然后介绍如何用 Canvas<br>的 API 来绘制 2D 图形，然后介绍如何在 Canvas 上加载和绘制图像，接下来本例会在图片浏览器中加入其他基于 Canvas<br>的效果，最后是总结和展望。</p><br><br><br><table style="width: 100%;" border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td><img src="http://www.ibm.com/i/v14/rules/blue_rule.gif" alt="" width="100%" height="1"><br><br><br><img src="http://www.ibm.com/i/c.gif" border="0" alt="" width="8" height="6"><br></td><br></tr><br></tbody><br></table><br><table class="no-print" border="0" cellspacing="0" cellpadding="0" align="right"><br><tbody><br><tr align="right"><br><td><img src="http://www.ibm.com/i/c.gif" alt="" width="100%" height="4"><br><br><br><table border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td valign="middle"><img src="http://www.ibm.com/i/v14/icons/u_bold.gif" border="0" alt="" width="16" height="16"><br><br><br></td><br><td align="right" valign="top"><a class="fbox" href="http://www.ibm.com/developerworks/cn/web/0912_yanlin_htmlcanvas/#main" target="_blank" rel="noopener"><strong>回页首</strong><br></a><br></td><br></tr><br></tbody><br></table><br></td><br></tr><br></tbody><br></table><br><br><br><br><br><p><a name="major2"><span class="atitle">创建图片浏览器框架</span><br></a><br></p><br><p><a name="minor2.1"><span class="smalltitle">创建文件</span><br></a><br></p><br><p>首先我们创建一个新的 html 文件 thumbnail.html，加入如清单 1 所示的内容：</p><br><br><br><a name="listing1"><strong>清单 1.thumbnail.html</strong><br></a><br><br><br><table style="width: 100%;" border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td class="code-outline"><br><pre class="displaycode">                <br><br> &lt;!DOCTYPE HTML&gt; <br><br> &lt;html&gt; <br><br> &lt;head&gt; <br><br>  &lt;title&gt;Canvas Based Thumbnail&lt;/title&gt; <br><br>  &lt;style type=&quot;text/css&quot;&gt; <br><br>    body { <br><br>    background: black; <br><br>    color: white; <br><br>   font: 24pt Baskerville, Times, Times New Roman, serif; <br><br>    padding: 0; <br><br>    margin: 0; <br><br>    overflow: hidden; <br><br>    } <br><br>  &lt;/style&gt; <br><br>  &lt;script type=&quot;text/javascript&quot; src=&quot;thumbnail.js&quot;&gt;&lt;/script&gt; <br><br> &lt;/head&gt; <br><br> &lt;body&gt; <br><br>  &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt; <br><br> &lt;/body&gt; <br><br> &lt;/html&gt; <br><br></pre><br></td><br></tr><br></tbody><br></table><br><br><br><p>这里我们可以看到，canvas 是 html<br>的一个新的标签，其用法和其他标签一样，只不过它的高和宽有独立的属性而不是在 css 定义的。如果我们要设置一个 Canvas<br>区域的宽高，必须定义为 &lt;canvas width=&quot;100&quot; height=&quot;100&quot;&gt; 而不能是 &lt;canvas<br>style=&quot;width:100,height:100&quot;&gt;。在上面的 html 文件中我们没有直接定义 Canvas 区域的大小，而是在<br>JavaScript 中动态定义，下面将要详细说明。</p><br><p>现在我们创建一个新的 JavaScript 文件<br>thumbnail.js 来在 Canvas 中绘制图像，我们设计一个 thumbnail<br>类，该类可以处理用户事件，绘制图形，显示图像。然后在 window.onload 事件中加载该类，代码如清单 2 所示：</p><br><br><br><a name="listing2"><strong>清单 2 .thumbnail.js</strong><br></a><br><br><br><table style="width: 100%;" border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td class="code-outline"><br><pre class="displaycode">                <br><br> function thumbnail() { <br><br>    this.load = function() <br><br>    } <br><br> } <br><br><br><br> window.onload = function() { <br><br>    thumb = new thumbnail(); <br><br>    thumb.load(); <br><br> } <br><br></pre><br></td><br></tr><br></tbody><br></table><br><br><br><p>代码定义了一个初始化函数 load，并且声明了 thumbnail 类，这样我们就可以在 thumbnail 类中添加代码，在 Canvas 上绘制各种图形以及图像了。</p><br><p>设计界面</p><br><p>我<br>们为这个图片浏览页面设计这样一种界面，图片通过缩放占满全部网页空间，在中间下方，绘制一个导航栏，显示缩略图，当点击缩略图时，该图片显示到网页中。<br>同时，如果鼠标悬停在某个缩放图上，则显示一个大一点的预览图用来供用户预览。在导航栏的左右两边，添加 2<br>个按钮，用于翻页显示上一页和下一页的缩略图。对导航栏上所有控件的尺寸大小和位置如图 1 所示的方案。这样，我们就可以按照该方案在 Canvas<br>上绘制这些控件了。</p><br><br><br><a name="fig1"><strong>图 1. 界面设计</strong><br></a><br><br><br>                <img src="http://www.ibm.com/developerworks/cn/web/0912_yanlin_htmlcanvas/image003.gif" alt="图 1 界面设计" width="526" height="321"><br>            <br><br>            <br><br><table style="width: 100%;" border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td><img src="http://www.ibm.com/i/v14/rules/blue_rule.gif" alt="" width="100%" height="1"><br><br><br><img src="http://www.ibm.com/i/c.gif" border="0" alt="" width="8" height="6"><br></td><br></tr><br></tbody><br></table><br><table class="no-print" border="0" cellspacing="0" cellpadding="0" align="right"><br><tbody><br><tr align="right"><br><td><img src="http://www.ibm.com/i/c.gif" alt="" width="100%" height="4"><br><br><br><table border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td valign="middle"><img src="http://www.ibm.com/i/v14/icons/u_bold.gif" border="0" alt="" width="16" height="16"><br><br><br></td><br><td align="right" valign="top"><a class="fbox" href="http://www.ibm.com/developerworks/cn/web/0912_yanlin_htmlcanvas/#main" target="_blank" rel="noopener"><strong>回页首</strong><br></a><br></td><br></tr><br></tbody><br></table><br></td><br></tr><br></tbody><br></table><br><br><br><br><br><p><a name="major3"><span class="atitle">用 Canvas 绘制图形</span><br></a><br></p><br><p><a name="minor3.1"><span class="smalltitle">绘制导航框</span><br></a><br></p><br><p>首先我们绘制如图 2 所示的一个导航栏。在左右两边各有一个按钮，按钮上显示一个三角形的指示图形。当鼠标放到一个按钮上时，按钮的背景色能变成高亮的颜色，显示当前选中的按钮。</p><br><br><br><a name="fig2"><strong>图 2. 导航框</strong><br></a><br><br><br>                <img src="http://www.ibm.com/developerworks/cn/web/0912_yanlin_htmlcanvas/image005.jpg" alt="图 2 导航框" width="326" height="46"><br>            <br><br><p>清单 3 显示了绘制图 2 所示的导航栏的代码片段。</p><br><br><br><a name="listing3"><strong>清单 3 . 绘制导航框代码</strong><br></a><br><br><br><table style="width: 100%;" border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td class="code-outline"><br><pre class="displaycode">                <br><br> function thumbnail() { <br><br>    const NAVPANEL_COLOR = ‘rgba(100, 100, 100, 0.2)’;    // 导航栏背景色<br><br>    const NAVBUTTON_BACKGROUND = ‘rgb(40, 40, 40)’;  // 导航栏中 button 的背景色<br><br>    const NAVBUTTON_COLOR = ‘rgb(255, 255, 255)’;   //button 的前景色<br><br>    const NAVBUTTON_HL_COLOR = ‘rgb(100, 100, 100)’;   //button 高亮时的前景色<br><br><br><br>    var canvas = document.getElementById(‘canvas’);   // 获得 canvas 对象<br><br>    var context = canvas.getContext(‘2d’);    // 获得上下文对象<br><br> <br><br>    // 绘制左边 button <br><br>    function paintLeftButton(navRect, color) { <br><br>        //left button <br><br>        lButtonRect = { <br><br>            x: navRect.x + NAVBUTTON_XOFFSET, <br><br>            y: navRect.y + NAVBUTTON_YOFFSET, <br><br>            width: NAVBUTTON_WIDTH, <br><br>            height: navRect.height - NAVBUTTON_YOFFSET <em> 2 <br><br>        } <br><br><br><br>        context.save(); <br><br>        context.fillStyle = color; <br><br>        context.fillRect(lButtonRect.x, lButtonRect.y, <br><br> lButtonRect.width, lButtonRect.height); <br><br><br><br>        //left arrow <br><br>        context.save(); <br><br>        context.fillStyle = NAVBUTTON_COLOR; <br><br>        context.beginPath(); <br><br>        context.moveTo(lButtonRect.x + NAVBUTTON_ARROW_XOFFSET, <br><br> lButtonRect.y + lButtonRect.height/2); <br><br>        context.lineTo(lButtonRect.x + lButtonRect.width - NAVBUTTON_ARROW_XOFFSET, <br><br> lButtonRect.y + NAVBUTTON_ARROW_YOFFSET); <br><br>        context.lineTo(lButtonRect.x + lButtonRect.width - NAVBUTTON_ARROW_XOFFSET, <br><br> lButtonRect.y + lButtonRect.height - NAVBUTTON_ARROW_YOFFSET); <br><br>        context.lineTo(lButtonRect.x + NAVBUTTON_ARROW_XOFFSET, <br><br> lButtonRect.y + lButtonRect.height/2); <br><br>        context.closePath(); <br><br>        context.fill(); <br><br>        context.restore(); <br><br><br><br>        context.restore(); <br><br>    } <br><br></em></pre><br></td><br></tr><br></tbody><br></table><br><br><br><p>如上所述，在页面 html 中我们声明了<br>&lt;canvas&gt; 元素。当需要在 &lt;canvas&gt;<br>区域绘制图形时，我们需要获得绘制图形的上下文对象，在一个上下文对象中，保存了当前的初始坐标位置，颜色，风格等等信息。这里我们通过如清单 4<br>的语句获取 Canvas 的 2 维绘图的上下文对象。</p><br><br><br><a name="listing4"><strong>清单 4. 获得绘图上下文</strong><br></a><br><br><br><table style="width: 100%;" border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td class="code-outline"><br><pre class="displaycode">                <br><br> var canvas = document.getElementById(‘canvas’); <br><br> var context = canvas.getContext(‘2d’); <br><br></pre><br></td><br></tr><br></tbody><br></table><br><br><br><p>获得上下文对象之后，我们就可以通过 Canvas 提供的 API 来进行绘画了。在清单 5 中，我们使用了矩形的绘制函数来绘制整个导航栏背景和左右两个按钮。所下所示：</p><br><br><br><a name="listing5"><strong>清单 5. 矩形绘制函数</strong><br></a><br><br><br><table style="width: 100%;" border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td class="code-outline"><br><pre class="displaycode">                <br><br> fillRect(x,y,width,height)： 绘制一个填充的矩形<br><br> strokeRect(x,y,width,height)： 给一个矩形描边<br><br> clearRect(x,y,width,height)： 清除该矩形内所有内容使之透明<br><br></pre><br></td><br></tr><br></tbody><br></table><br><br><br><p>例如，我们要绘制一个简单的矩形可以用如清单 6 所示代码：</p><br><br><br><a name="listing6"><strong>清单 6. 绘制简单矩形</strong><br></a><br><br><br><table style="width: 100%;" border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td class="code-outline"><br><pre class="displaycode">                <br><br> var canvas = document.getElementById(‘canvas’); <br><br> var context = canvas.getContext(‘2d’); <br><br> context.fillStyle = ‘black’; <br><br> context.fillRect(0, 0, 50, 50); <br><br> context.clearRect(0, 0, 20, 20); <br><br> context.strokeRect(0, 0, 20, 20); <br><br></pre><br></td><br></tr><br></tbody><br></table><br><br><br><p>我们绘制该导航框时，需要在左右两边各绘制一个三角形，对于除了矩形以外的所有多边形，必须得通过路径来绘制，常用的路径相关函数有 :</p><br><br><br><a name="listing7"><strong>清单 7. 绘制路径函数</strong><br></a><br><br><br><table style="width: 100%;" border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td class="code-outline"><br><pre class="displaycode">                <br><br> beginPath(): 开始一段路径 <br><br> closePath(): 结束一段路径<br><br> moveTo(x,y)  : 移动起始点到某点<br><br> lineTo(x,y) ： 绘制线段到目标点<br><br></pre><br></td><br></tr><br></tbody><br></table><br><br><br><p>这样，我们在绘制三角形的时候，只需要确定三个顶点的坐标，就可以通过 lineTo 函数绘制三条线段，但是，我们还需要一个函数在该三角形区域内填充颜色，这样需要用到填充和描边的函数和样式：</p><br><br><br><a name="listing8"><strong>清单 8. 填充和描边样式</strong><br></a><br><br><br><table style="width: 100%;" border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td class="code-outline"><br><pre class="displaycode">                <br><br> fillStyle = color ： 设置填充颜色<br><br> storkeStyle = color : 设置描变颜色<br><br></pre><br></td><br></tr><br></tbody><br></table><br><br><br><p>这里 color 值可以是标准的 CSS 颜色值，还可以通过 rgba 函数设置透明度。我们可以如下设置：</p><br><br><br><a name="listing9"><strong>清单 9. 填充样式举例</strong><br></a><br><br><br><table style="width: 100%;" border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td class="code-outline"><br><pre class="displaycode">                <br><br> context.fillStyle = &quot;white&quot;; <br><br> context.strokeStyle = &quot;#FFA500&quot;; <br><br> context.fillStyle = &quot;rgb(255,165,0)&quot;; <br><br> context.fillStyle = &quot;rgba(255,165,0,1)&quot;; <br><br></pre><br></td><br></tr><br></tbody><br></table><br><br><br><p>同样，当需要填充颜色样式或者描边时，有如下函数：</p><br><br><br><a name="listing10"><strong>清单 10. 填充和描边函数</strong><br></a><br><br><br><table style="width: 100%;" border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td class="code-outline"><br><pre class="displaycode">                <br><br> stroke() : 按照当前描边样式描边当前路径<br><br> fill() : 按照当前填充样式填充路径所描述的形状<br><br></pre><br></td><br></tr><br></tbody><br></table><br><br><br><p>这样，用上述几个函数，我们绘制一个三角形时，可以用如下语句：</p><br><br><br><a name="listing11"><strong>清单 11. 绘制三角形代码</strong><br></a><br><br><br><table style="width: 100%;" border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td class="code-outline"><br><pre class="displaycode">                <br><br> var canvas = document.getElementById(‘canvas’); <br><br> var context = canvas.getContext(‘2d’); <br><br> context.fillStyle = ‘black’; <br><br> context.beginPath(); <br><br> context.moveTo(0,0); <br><br> context.lineTo(10,0); <br><br> context.lineTo(10,10); <br><br> context.lineTo(0,0); <br><br> context.closePath(); <br><br> context.fill(); <br><br></pre><br></td><br></tr><br></tbody><br></table><br><br><br><p>在清单 3 中，我们还声明了一些常量来定义导航栏的各种控件的大小，其中长度值都是以像素为单位的。这样我们绘制了整个导航栏，但我们现在需要当鼠标放到按钮上时，按钮的前景色能够高亮，显示当前选中的按钮。这就需要我们在代码中响应用户事件，并进行不同类型的绘制。</p><br><p><a name="minor3.2"><span class="smalltitle">响应用户事件</span><br></a><br></p><br><p>响应用户事件和普通的 DOM 编程类似，如清单 12 所示：</p><br><br><br><a name="listing12"><strong>清单 12. 响应鼠标移动时间</strong><br></a><br><br><br><table style="width: 100%;" border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td class="code-outline"><br><pre class="displaycode">                <br><br>    var lastMousePos;    // 当前鼠标位置<br><br>    this.load = function() { <br><br>        //event binding <br><br>        canvas.onmousemove = onMouseMove; <br><br>    } <br><br>    function onMouseMove(event) { <br><br>        lastMousePos = {x:event.clientX, y:event.clientY}; <br><br>        paint(); <br><br>    } <br><br>    function pointIsInRect(point, rect) { <br><br>        return (rect.x &lt; point.x &amp;&amp; point.x &lt; rect.x + rect.width &amp;&amp; <br><br>                rect.y &lt; point.y &amp;&amp; point.y &lt; rect.y + rect.height); <br><br>    } <br><br>    function paint() { <br><br>        context.clearRect(0, 0, canvas.width, canvas.height); <br><br>        var paintInfo = {inLeftBtn:false, inRightBtn:false} <br><br><br><br>        if (lastMousePos &amp;&amp; navRect &amp;&amp; lButtonRect &amp;&amp; rButtonRect) { <br><br>            if (pointIsInRect(lastMousePos, navRect)) { <br><br>                paintInfo.inLeftBtn = pointIsInRect(lastMousePos, lButtonRect); <br><br>                paintInfo.inRightBtn = pointIsInRect(lastMousePos, rButtonRect); <br><br>            } <br><br>        } <br><br>        paintNavigator(paintInfo); <br><br>    } <br><br></pre><br></td><br></tr><br></tbody><br></table><br><br><br><p>这样我们就绘制了一个完整的导航栏，它能够响应鼠标移动事件，并高亮当前选中的按钮。下面我们需要加载和显示图片，这就需要用到 Canvas 的绘制图像函数。</p><br><br><br><table style="width: 100%;" border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td><img src="http://www.ibm.com/i/v14/rules/blue_rule.gif" alt="" width="100%" height="1"><br><br><br><img src="http://www.ibm.com/i/c.gif" border="0" alt="" width="8" height="6"><br></td><br></tr><br></tbody><br></table><br><table class="no-print" border="0" cellspacing="0" cellpadding="0" align="right"><br><tbody><br><tr align="right"><br><td><img src="http://www.ibm.com/i/c.gif" alt="" width="100%" height="4"><br><br><br><table border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td valign="middle"><img src="http://www.ibm.com/i/v14/icons/u_bold.gif" border="0" alt="" width="16" height="16"><br><br><br></td><br><td align="right" valign="top"><a class="fbox" href="http://www.ibm.com/developerworks/cn/web/0912_yanlin_htmlcanvas/#main" target="_blank" rel="noopener"><strong>回页首</strong><br></a><br></td><br></tr><br></tbody><br></table><br></td><br></tr><br></tbody><br></table><br><br><br><br><br><p><a name="major4"><span class="atitle">用 Canvas 绘制图像</span><br></a><br></p><br><p><a name="minor4.1"><span class="smalltitle">加载和显示图像</span><br></a><br></p><br><p>加载和显示图像的代码片段如清单 13 所示：</p><br><br><br><a name="listing13"><strong>清单 13. 加载和显示图像</strong><br></a><br><br><br><table style="width: 100%;" border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td class="code-outline"><br><pre class="displaycode">                <br><br>    const PAINT_INTERVAL = 20;  // 循环间隔<br><br>    const PAINT_SLOW_INTERVAL = 20000;   <br><br>    const IDLE_TIME_OUT = 3000;  // 空闲超时时间<br><br><br><br>    // 定义全部图片 URL 数组，在本例中，所有图片保存在和网页同目录中<br><br>    var imageLocations = [ <br><br>    ‘2006109173628.jpg’, <br><br>    ‘2007310132939.jpg’, <br><br>    ‘200733094828-1.jpg’<br><br>    ]; <br><br>   // 加载图片<br><br>    function loadImages() { <br><br>        var total = imageLocations.length; <br><br>        var imageCounter = 0; <br><br>        var onLoad = function(err, msg) { <br><br>            if (err) { <br><br>                console.log(msg); <br><br>            } <br><br>            imageCounter++; <br><br>            if (imageCounter == total) { <br><br>                loadedImages = true; <br><br>            } <br><br>        } <br><br><br><br>        for (var i = 0; i &lt; imageLocations.length; i++) { <br><br>            var img = new Image(); <br><br>            img.onload = function() { onLoad(false); }; <br><br>            img.onerror = function() { onLoad(true, e);}; <br><br>            img.src = imageLocations[i]; <br><br>            images[i] = img; <br><br>        } <br><br>    } <br><br>    // 绘制图片<br><br>    function paintImage(index) { <br><br>        if (!loadedImages) <br><br>            return; <br><br>        var image = images[index]; <br><br>        var screen_h = canvas.height; <br><br>        var screen_w = canvas.width; <br><br>        var ratio = getScaleRatio({width:image.width, height:image.height}, <br><br> {width:screen_w, height:screen_h}); <br><br>    var img_h = image.height  ratio; <br><br>    var img_w = image.width <em> ratio; <br><br><br><br>    context.drawImage(image, (screen_w - img_w)/2, (screen_h - img_h)/2, img_w, img_h); <br><br>    } <br><br></em></pre><br></td><br></tr><br></tbody><br></table><br><br><br><p>在清单 13 的代码中，我们更新了主绘制函数<br>paint，加入了 paintImage 函数，在 paintImage 函数中，利用 Canvas 的 drawImage 函数，在整个<br>Canvas 区域，尽可能大地缩放图片并显示在 Canvas 中，其最佳缩放比例如图 3 所示 :</p><br><br><br><a name="fig3"><strong>图 3. 最佳缩放比例示例</strong><br></a><br><br><br>                <img src="http://www.ibm.com/developerworks/cn/web/0912_yanlin_htmlcanvas/image007.gif" alt="图 3 . 最佳缩放比例示例" width="414" height="198"><br>            <br><br><p>这里缩放比例是通过本例所定义的函数 getScaleRatio 来获得的，其详细代码见附件。这样我们可以在 Canvas 上绘制图像，绘制图像的函数定义如下 :</p><br><br><br><a name="listing14"><strong>清单 14. 绘制图像函数</strong><br></a><br><br><br><table style="width: 100%;" border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td class="code-outline"><br><pre class="displaycode">                <br><br> drawImage(image, x, y)   image 为一个图像或者 Canvas 对象，x，y 为图片所要放至位置的左上角坐标<br><br></pre><br></td><br></tr><br></tbody><br></table><br><br><br><p>但该函数还无法满足我们的要求，我们需要缩放图片到一个最佳大小，这就需要 Canvas 绘制图片函数的另外一种形式：</p><br><br><br><a name="listing15"><strong>清单 15. 绘制图像函数 2</strong><br></a><br><br><br><table style="width: 100%;" border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td class="code-outline"><br><pre class="displaycode">                <br><br> drawImage(image, x, y, width, height)     width, height 为图像在目标 Canvas 上的大小<br><br></pre><br></td><br></tr><br></tbody><br></table><br><br><br><p>该函数将图片缩放到 width 和 height 所指定的大小并显示出来。我们通过函数 getScaleRatio 来计算最佳缩放大小，然后就可以通过如清单 15 所示来绘制最佳大小的图片。</p><br><p>绘<br>制图片需要传入一个 image 对象，它一般是一个图片或者 Canvas 对象。也就是说你可以从一个 URL 中下载图片显示在 Canvas<br>中，也可以在一个 Canvas 中显示另外一个 Canvas 中绘制的图形。通过如清单 16 所示的代码来加载图片：</p><br><br><br><a name="listing16"><strong>清单 16. 加载图片代码</strong><br></a><br><br><br><table style="width: 100%;" border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td class="code-outline"><br><pre class="displaycode">                <br><br>    var onLoad = function(err, msg) { <br><br>        if (err)   console.log(msg); <br><br>    } <br><br>    var img = new Image(); <br><br>    img.onload = function() { onLoad(false); }; <br><br>    img.onerror = function() { onLoad(true, e);}; <br><br>    img.src = &lsquo; myImage.png &rsquo; ;  // 设置源路径<br><br></pre><br></td><br></tr><br></tbody><br></table><br><br><br><p>在整个程序中，我们利用了 setInterval<br>函数加入了一个定时器来触发主循环，用于不断循环等待全部图片加载。当等待时间超过一个阀值之后，主循环进入 idle<br>状态，该循环不仅能够用于等待全部图片加载，也可以用于绘制动画效果，我们在后面将会讲到如何利用该主循环来制作动态效果。</p><br><p>绘制缩略图</p><br><p>下一步需要在导航栏中绘制每个图片的缩略图，该缩略图必须按照最优的大小和间隔排列在导航栏中，同时缩略图必须经过裁剪，获得最优的显示区域。整体效果如图 4 所示：</p><br><br><br><a name="fig4"><strong>图 4. 缩略图效果</strong><br></a><br><br><br>                <img src="http://www.ibm.com/developerworks/cn/web/0912_yanlin_htmlcanvas/image009.jpg" alt="图 4 . 缩略图效果" width="537" height="319"><br>            <br><br><p>实现代码片段如清单 17 所示：</p><br><br><br><a name="listing17"><strong>清单 17. 缩略图代码</strong><br></a><br><br><br><table style="width: 100%;" border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td class="code-outline"><br><pre class="displaycode">                <br><br>    const HL_OFFSET = 3;   <br><br>    const THUMBNAIL_LENGTH = NAVPANEL_HEIGHT - NAVBUTTON_YOFFSET2;   // 缩略图显示区域的高度<br><br>    const MIN_THUMBNAIL_LENGTH = 10;  // 最小缩略图间隔<br><br><br><br>    var currentImage = 0;   // 当前图片序号<br><br>    var firstImageIndex = 0;  // 当前缩略图中第一张图片序号<br><br>    var thumbNailCount = 0;  // 当前显示的缩略图数<br><br>    var maxThumbNailCount = 0;  // 最大能够显示的缩略图数<br><br>    // 绘制缩略图<br><br>    function paintThumbNails(inThumbIndex) { <br><br>        if (!loadedImages) <br><br>            return; <br><br>        <br><br>        if(inThumbIndex != null) { <br><br>            inThumbIndex -= firstImageIndex; <br><br>        } else { <br><br>            inThumbIndex = -1; <br><br>        } <br><br><br><br>        var thumbnail_length = rButtonRect.x - lButtonRect.x - lButtonRect.width; <br><br>        maxThumbNailCount = Math.ceil(thumbnail_length / THUMBNAIL_LENGTH); <br><br>        var offset = (thumbnail_length - THUMBNAIL_LENGTH <em> maxThumbNailCount) / <br><br> (maxThumbNailCount + 1); <br><br>        if (offset &lt; MIN_THUMBNAIL_LENGTH) { <br><br>            maxThumbNailCount = Math.ceil(thumbnail_length/ (THUMBNAIL_LENGTH + <br><br> MIN_THUMBNAIL_LENGTH)); <br><br>            offset = (thumbnail_length - THUMBNAIL_LENGTH </em> maxThumbNailCount) / <br><br> (maxThumbNailCount + 1); <br><br>        } <br><br><br><br>        thumbNailCount = maxThumbNailCount &gt; imageCount - firstImageIndex? <br><br> imageCount - firstImageIndex: maxThumbNailCount; <br><br><br><br>        imageRects = new Array(thumbNailCount); <br><br><br><br>        for (var i = 0; i &lt; thumbNailCount; i++) { <br><br>            image = images[i+firstImageIndex]; <br><br>            context.save(); <br><br>            var x = lButtonRect.x + lButtonRect.width + (offset+THUMBNAIL_LENGTH)<em>i; <br><br>            srcRect = getSlicingSrcRect({width:image.width, height:image.height}, <br><br> {width:THUMBNAIL_LENGTH, height: THUMBNAIL_LENGTH}); <br><br>            imageRects[i] = { <br><br>                image:image, <br><br>                rect: { <br><br>                    x:x+offset, <br><br>                    y:inThumbIndex == i? navRect.y+NAVBUTTON_YOFFSET-HL_OFFSET: <br><br> navRect.y+NAVBUTTON_YOFFSET, <br><br>                    height: THUMBNAIL_LENGTH, <br><br>                    width: THUMBNAIL_LENGTH <br><br>                } <br><br>            } <br><br><br><br>            context.translate(x, navRect.y); <br><br>            context.drawImage(image, srcRect.x, srcRect.y, <br><br> srcRect.width, srcRect.height, <br><br> offset, imageRects[i].rect.y - navRect.y, <br><br> THUMBNAIL_LENGTH, THUMBNAIL_LENGTH); <br><br>            context.restore(); <br><br>        } <br><br>    } <br><br></em></pre><br></td><br></tr><br></tbody><br></table><br><br><br><p>清单 17 的代码使用了 Canvas 中坐标转换的方法来绘制每张缩略图。转换坐标函数如清单 18 所示：</p><br><br><br><a name="listing18"><strong>清单 18. 转换坐标函数</strong><br></a><br><br><br><table style="width: 100%;" border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td class="code-outline"><br><pre class="displaycode">                <br><br> translate(x, y)  x 为横轴偏移方向大小，y 为纵轴方向偏移大小<br><br></pre><br></td><br></tr><br></tbody><br></table><br><br><br><p>其原理如图 5 所示：</p><br><br><br><a name="fig5"><strong>图 5. 转换坐标</strong><br></a><br><br><br>                <img src="http://www.ibm.com/developerworks/cn/web/0912_yanlin_htmlcanvas/image011.gif" alt="图 5. 转换坐标" width="162" height="143"><br>            <br><br><p>Canvas<br>绘图的坐标系和大部分操作系统绘图的坐标系一致，都是左上角为原点，向右为 x 方向，向下为 y 方向。从图 5 中我们看出，新的坐标原点平移到了<br>(x,y) 位置，后面的 Canvas 绘图函数都是以新的原点为基准绘图。清单 17<br>在绘制每张缩略图时，首先转换原点到缩略图的左上角，然后在固定的 x 和 y<br>坐标位置显示图片，将这个过程做成一个循环，就绘制了所有等间距的缩略图。</p><br><p>将图片显示到缩略图中，我们还需要把图片缩放到其中较短的一边能够和缩略图的边长重合，同时截去超出缩略图大小的图片部分，从而达到最优的显示缩略图的效果。其示意图如图 6 所示。</p><br><br><br><a name="fig6"><strong>图 6. 截取最佳图片部分</strong><br></a><br><br><br>                <img src="http://www.ibm.com/developerworks/cn/web/0912_yanlin_htmlcanvas/image013.gif" alt="图 6. 截取最佳图片部分" width="390" height="178"><br>            <br><br><p>为<br>了获得这种最优的缩略图显示效果，我们需要获得如下信息：1. 原图中应该截取哪些部分图片；２ . 缩放多大的比例到目标区域中。本例定义了函数<br>getSlicingSrcRect 实现了这个功能，它返回一个 rect<br>对象，包括了应该截取原图的哪些区域，其详细代码见附件。但还需要一个函数来将这个截取的图片部分缩放到目标区域中，这就用到了 Canvas<br>绘制图像函数 drawImage 的另外一种形式：</p><br><br><br><a name="listing19"><strong>清单 19. 绘制图像函数 3</strong><br></a><br><br><br><table style="width: 100%;" border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td class="code-outline"><br><pre class="displaycode">                <br><br> drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) 　 <br><br> sx, sy, sWidth, sHeight 为原图中的需要截取的区域，　 dx, dy, dWidth, dHeight 为目标区域的位置大小<br><br></pre><br></td><br></tr><br></tbody><br></table><br><br><br><p>该函数截取原图片的部分区域，然后缩放显示到目标区域中。我们利用这个函数，就能够实现截取最佳区域以显示在缩略图中的效果。</p><br><p>在绘制缩略图我们还实现了一个小技巧：缩略图大小是固定的，但之间的间距是动态调整的，当缩略图之间的间距小于一个阀值的时候，我们强制最小间隔不小于阀值，详细代码请看清单 17。</p><br><p><a name="minor4.2"><span class="smalltitle">响应点击事件</span><br></a><br></p><br><p>显示缩略图以后，我们需要响应点击事件，即能够点击缩略图，显示所对应的图片。同时，我们还需要点击左右两边的按钮，能够实现缩略图的翻页。这是通过清单 20 所示的代码实现的：</p><br><br><br><a name="listing20"><strong>清单 20 . 响应鼠标点击事件</strong><br></a><br><br><br><table style="width: 100%;" border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td class="code-outline"><br><pre class="displaycode">                <br><br>    // 加入了鼠标点击事件的响应<br><br>    this.load = function() { <br><br>        //event binding <br><br>        canvas.onclick = onMouseClick; <br><br>        canvas.onmousemove = onMouseMove; <br><br> } <br><br> // 鼠标点击事件处理<br><br>    function onMouseClick(event) { <br><br>        point = {x: event.clientX, y:event.clientY}; <br><br>        lastMousePos = point; <br><br><br><br>        if (pointIsInRect(point, lButtonRect)) { <br><br>            nextPane(true); <br><br>        } else if (pointIsInRect(point, rButtonRect)) { <br><br>            nextPane(false); <br><br>        } else { <br><br>            var selectedIndex = findSelectImageIndex(point); <br><br>            if (selectedIndex != -1) { <br><br>                selectImage(selectedIndex); <br><br>            } <br><br>        } <br><br>        updateIdleTime(); <br><br>    } <br><br>    // 返回所点击的缩略图序号，如果没有点击缩略图则返回 -1 <br><br>    function findSelectImageIndex(point) { <br><br>        for(var i = 0; i &lt; imageRects.length; i++) { <br><br>            if (pointIsInRect(point, imageRects[i].rect)) <br><br>                return i + firstImageIndex;        <br><br> } <br><br>        return -1; <br><br>    } <br><br>    // 将当前图片序号设为 index，重画<br><br>    function selectImage(index) { <br><br>        currentImage = index; <br><br>        paint(); <br><br>    } <br><br>    // 将缩略图翻页，更新缩略图中第一张图片的序号<br><br>    function nextPane(previous) { <br><br>        if (previous) { <br><br>            firstImageIndex = firstImageIndex - maxThumbNailCount &lt; 0? <br><br> 0 : firstImageIndex - maxThumbNailCount; <br><br>        } else { <br><br>            firstImageIndex = firstImageIndex + maxThumbNailCount2 - 1 &gt; imageCount - 1? <br><br> (imageCount - maxThumbNailCount &gt; 0? imageCount - maxThumbNailCount: 0) : <br><br> firstImageIndex + maxThumbNailCount; <br><br>            <br><br>        } <br><br>        currentImage = (firstImageIndex &lt;= currentImage &amp;&amp; <br><br> currentImage &lt;= firstImageIndex + maxThumbNailCount)? currentImage : firstImageIndex; <br><br>        paint(); <br><br>    } <br><br></pre><br></td><br></tr><br></tbody><br></table><br><br><br><p>这里我们通过 2 个变量 firstImageIndex 和 currentImage 来控制缩略图和当前图片的显示，并能够根据鼠标点击来改变当前选中的图片。</p><br><br><br><table style="width: 100%;" border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td><img src="http://www.ibm.com/i/v14/rules/blue_rule.gif" alt="" width="100%" height="1"><br><br><br><img src="http://www.ibm.com/i/c.gif" border="0" alt="" width="8" height="6"><br></td><br></tr><br></tbody><br></table><br><table class="no-print" border="0" cellspacing="0" cellpadding="0" align="right"><br><tbody><br><tr align="right"><br><td><img src="http://www.ibm.com/i/c.gif" alt="" width="100%" height="4"><br><br><br><table border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td valign="middle"><img src="http://www.ibm.com/i/v14/icons/u_bold.gif" border="0" alt="" width="16" height="16"><br><br><br></td><br><td align="right" valign="top"><a class="fbox" href="http://www.ibm.com/developerworks/cn/web/0912_yanlin_htmlcanvas/#main" target="_blank" rel="noopener"><strong>回页首</strong><br></a><br></td><br></tr><br></tbody><br></table><br></td><br></tr><br></tbody><br></table><br><br><br><br><br><p><a name="major5"><span class="atitle">加入其他效果</span><br></a><br></p><br><p><a name="minor5.1"><span class="smalltitle">根据当前窗口大小调整 Canvas 大小</span><br></a><br></p><br><p>当浏览器的大小改变的时候，我们的图片浏览器就会由于没能重画导致部分区域无法显示。我们需要根据浏览器当前页面大小来动态定义整个图片浏览器的大小，从而能够调整整个图片浏览器的最佳大小。代码如清单 21 所示：</p><br><br><br><a name="listing21"><strong>清单 21 .Resize 支持</strong><br></a><br><br><br><table style="width: 100%;" border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td class="code-outline"><br><pre class="displaycode">                <br><br>    this.load = function() { <br><br>        //resize <br><br>        resize(); <br><br>        window.onresize = resize; <br><br>        <br><br>        //event binding <br><br>        canvas.onclick = onMouseClick; <br><br>        canvas.onmousemove = onMouseMove; <br><br><br><br>        loadImages();        <br><br><br><br>        startLoop(); <br><br>        updateIdleTime(); <br><br>    } <br><br>    function resize() { <br><br>        var size = getScreenSize(); <br><br>        canvas.width = size.width; <br><br>        canvas.height = size.height; <br><br>        paint(); <br><br>    } <br><br><br><br>    function getScreenSize() { <br><br>        return { width: document.documentElement.clientWidth, <br><br> height: document.documentElement.clientHeight}; <br><br>    } <br><br></pre><br></td><br></tr><br></tbody><br></table><br><br><br><p>这里代码响应了 window 对象的 onresize<br>事件，从而能够响应整个浏览器页面大小改变的事件，通过 document.documentElement.clientWidth 和<br>document.documentElement.clientHeight 这两个 DOM<br>属性，我们获得了当前页面显示范围大小，从而能够动态调整 Canvas 的大小到最佳位置。</p><br><p><a name="minor5.2"><span class="smalltitle">显示缩略图预览</span><br></a><br></p><br><p>我们还需要实现这种效果：当鼠标放置在某个缩略图上方时，能够显示一个缩略图预览界面，其效果如图 7 所示：</p><br><br><br><a name="fig7"><strong>图 7 . 缩略图预览</strong><br></a><br><br><br>                <img src="http://www.ibm.com/developerworks/cn/web/0912_yanlin_htmlcanvas/image015.jpg" alt="图 7 . 缩略图预览" width="138" height="110"><br>            <br><br><p>实现代码如清单 22 所示：</p><br><br><br><a name="listing22"><strong>清单 22 . 缩略图预览代码</strong><br></a><br><br><br><table style="width: 100%;" border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td class="code-outline"><br><pre class="displaycode">                <br><br>    const ARROW_HEIGHT = 10;  // 下方三角形的高度<br><br>    const BORDER_WRAPPER = 2;   // 边缘白框的厚度<br><br>    // 绘制预览图<br><br>    function paintHighLightImage(srcRect, imageRect) { <br><br>      var ratio = imageRect.image.width == srcRect.width? <br><br>      <br><br>      THUMBNAIL_LENGTH/imageRect.image.width:THUMBNAIL_LENGTH/imageRect.image.height; <br><br>      ratio <em>= 1.5; <br><br><br><br>        var destRect = { <br><br>            x:imageRect.rect.x + imageRect.rect.width/2 - imageRect.image.width</em>ratio/2, <br><br>            y:navRect.y - ARROW_HEIGHT - BORDER_WRAPPER - imageRect.image.height<em>ratio, <br><br>            width: imageRect.image.width </em> ratio, <br><br>            height: imageRect.image.height <em> ratio <br><br>        } <br><br><br><br>        var wrapperRect = { <br><br>            x: destRect.x - BORDER_WRAPPER, <br><br>            y: destRect.y - BORDER_WRAPPER, <br><br>            width: destRect.width + BORDER_WRAPPER </em> 2, <br><br>            height: destRect.height + BORDER_WRAPPER <em> 2 <br><br>        } <br><br><br><br>        var arrowWidth = ARROW_HEIGHT </em> Math.tan(30/180*Math.PI); <br><br><br><br>        context.save(); <br><br>        context.fillStyle = ‘white’; <br><br>        context.translate(wrapperRect.x, wrapperRect.y); <br><br>        context.beginPath(); <br><br>        context.moveTo(0, 0); <br><br>        context.lineTo(wrapperRect.width, 0); <br><br>        context.lineTo(wrapperRect.width, wrapperRect.height); <br><br>        context.lineTo(wrapperRect.width/2 + arrowWidth, wrapperRect.height); <br><br>        context.lineTo(wrapperRect.width/2, wrapperRect.height+ARROW_HEIGHT); <br><br>        context.lineTo(wrapperRect.width/2 - arrowWidth, wrapperRect.height); <br><br>        context.lineTo(0, wrapperRect.height); <br><br>        context.lineTo(0, 0); <br><br>        context.closePath(); <br><br>        context.fill(); <br><br>        context.drawImage(imageRect.image, BORDER_WRAPPER, BORDER_WRAPPER, <br><br> destRect.width, destRect.height); <br><br>        context.restore(); <br><br>    } <br><br></pre><br></td><br></tr><br></tbody><br></table><br><br><br><p>在函数 paintHighLightImage 中大量使用了 Canvas 的路径绘图函数来绘制这个底部为三角形箭头，上部为矩形的形状。感兴趣的读者可以研究这些 Canvas 绘图函数的使用。</p><br><p><a name="minor5.3"><span class="smalltitle">自动隐藏</span><br></a><br></p><br><p>最后我们在加入一个动态的效果：当鼠标不再移动超过一定时刻的时候，导航栏能够自动隐藏。其代码如清单 23 所示：</p><br><br><br><a name="listing23"><strong>清单 23 . 自动隐藏代码</strong><br></a><br><br><br><table style="width: 100%;" border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td class="code-outline"><br><pre class="displaycode">                <br><br> // 加入了自动隐藏导航栏的功能<br><br>    function paint() { <br><br>        context.clearRect(0, 0, canvas.width, canvas.height); <br><br>        paintImage(currentImage); <br><br>        var paintInfo = {inLeftBtn:false, inRightBtn:false, inThumbIndex: null} <br><br><br><br>        if (lastMousePos &amp;&amp; navRect &amp;&amp; lButtonRect &amp;&amp; rButtonRect) { <br><br>            if (pointIsInRect(lastMousePos, navRect)) { <br><br>                paintInfo.inLeftBtn = pointIsInRect(lastMousePos, lButtonRect); <br><br>                paintInfo.inRightBtn = pointIsInRect(lastMousePos, rButtonRect); <br><br>                if (!paintInfo.inLeftBtn &amp;&amp; !paintInfo.inRightBtn) { <br><br>                    var index = findSelectImageIndex(lastMousePos); <br><br>                    if (index != -1) { <br><br>                        paintInfo.inThumbIndex = index; <br><br>                    } <br><br>                } <br><br>            } <br><br>        } <br><br>        if(idleTime &amp;&amp; getTime() - idleTime &lt;= IDLE_TIME_OUT) { <br><br>            paintNavigator(paintInfo); <br><br>        } <br><br>    } <br><br></pre><br></td><br></tr><br></tbody><br></table><br><br><br><p>当空闲时间超过阀值时，导航栏能够自动隐藏，这样浏览图片更加方便。</p><br><p><a name="minor5.4"><span class="smalltitle">最终效果</span><br></a><br></p><br><p>在合并了上述所有清单代码之后，我们在浏览器上就可以看到如图 8 所示的效果。</p><br><br><br><a name="fig8"><strong>图 8 . 完整的图片浏览器效果</strong><br></a><br><br><br>                <img src="http://www.ibm.com/developerworks/cn/web/0912_yanlin_htmlcanvas/image017.jpg" alt="图 8 . 完整的图片浏览器效果" width="520" height="307"><br>            <br><br><p>完整的代码请看附件。运行代码需要 Firefox 1.5, Chrome 1, Safari 3 以上版本的浏览器。</p><br><br><br><table style="width: 100%;" border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td><img src="http://www.ibm.com/i/v14/rules/blue_rule.gif" alt="" width="100%" height="1"><br><br><br><img src="http://www.ibm.com/i/c.gif" border="0" alt="" width="8" height="6"><br></td><br></tr><br></tbody><br></table><br><table class="no-print" border="0" cellspacing="0" cellpadding="0" align="right"><br><tbody><br><tr align="right"><br><td><img src="http://www.ibm.com/i/c.gif" alt="" width="100%" height="4"><br><br><br><table border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td valign="middle"><img src="http://www.ibm.com/i/v14/icons/u_bold.gif" border="0" alt="" width="16" height="16"><br><br><br></td><br><td align="right" valign="top"><a class="fbox" href="http://www.ibm.com/developerworks/cn/web/0912_yanlin_htmlcanvas/#main" target="_blank" rel="noopener"><strong>回页首</strong><br></a><br></td><br></tr><br></tbody><br></table><br></td><br></tr><br></tbody><br></table><br><br><br><br><br><p><a name="major6"><span class="atitle">总结及展望</span><br></a><br></p><br><p>本<br>文用图片浏览器的例子来说明 Canvas 的各种函数的使用。该例子也只是一个简单的 demo，并未涉及更为高级的 Canvas<br>使用，例如旋转坐标转换，绘制曲线，组合图形，渐变色彩等等。该例子也可以进一步改进，加入更多动态效果并提高效率。本文就不一一叙述。</p><br><p>从<br>上述例子我们也能看到，Canvas 作为 HTML 5 新的元素，其绘图功能已经很接近操作系统的渲染函数。Canvas<br>元素可以进行矢量绘图也可以进行位图的绘制，在不久的将来，Canvas 还能利用 WebGL 技术支持 3D<br>绘图，这为未来的的网页游戏制作和更为丰富的 Web 用户体验提供了便利。在最新的 Google Wave 平台中，就已经大量使用了<br>Canvas 技术来渲染用户界面。我相信，在不久的将来，Canvas 能够大量被广大网页设计师和架构师所使用，并进一步被得到完善和加强。</p><br><br><br><br><br><table style="width: 100%;" border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td><img src="http://www.ibm.com/i/v14/rules/blue_rule.gif" alt="" width="100%" height="1"><br><br><br><img src="http://www.ibm.com/i/c.gif" border="0" alt="" width="8" height="6"><br></td><br></tr><br></tbody><br></table><br><table class="no-print" border="0" cellspacing="0" cellpadding="0" align="right"><br><tbody><br><tr align="right"><br><td><img src="http://www.ibm.com/i/c.gif" alt="" width="100%" height="4"><br><br><br><table border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td valign="middle"><img src="http://www.ibm.com/i/v14/icons/u_bold.gif" border="0" alt="" width="16" height="16"><br><br><br></td><br><td align="right" valign="top"><a class="fbox" href="http://www.ibm.com/developerworks/cn/web/0912_yanlin_htmlcanvas/#main" target="_blank" rel="noopener"><strong>回页首</strong><br></a><br></td><br></tr><br></tbody><br></table><br></td><br></tr><br></tbody><br></table><br><br><br><br><br><p><span class="atitle"><a name="download">下载</a><br></span><br></p><br><table class="data-table-1" style="width: 100%;" border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><th scope="col">描述</th><br><th scope="col">名字</th><br><th scope="col">大小</th><br><th scope="col">下载方法</th><br></tr><br><tr><br><th class="tb-row" scope="row">示例代码</th><br><td>samplecode.zip</td><br><td>2176KB</td><br><td><a class="fbox" onclick="sa_onclick(this.href)" onkeypress="sa_onclick(this.href)" href="http://www.ibm.com/developerworks/cn/web/0912_yanlin_htmlcanvas/samplecode.zip" target="_blank" rel="noopener"><strong>HTTP</strong><br></a><br></td><br></tr><br></tbody><br></table><br><table border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr valign="top"><br><td colspan="5"><img src="http://www.ibm.com/i/c.gif" border="0" alt="" width="12" height="12"><br></td><br></tr><br><tr><br><td><img src="http://www.ibm.com/i/v14/icons/fw.gif" alt="" width="16" height="16"><br></td><br><td><a class="fbox" href="http://www.ibm.com/developerworks/cn/whichmethod.html" target="_blank" rel="noopener">关于下载方法的信息</a><br></td><br><td><img src="http://www.ibm.com/i/c.gif" alt="" width="50" height="1"><br></td><br></tr><br></tbody><br></table><br><br><br><br><br><p><a name="resources"><span class="atitle">参考资料 </span><br></a><br></p><br><ul><br><li><br>                参看系列文章&ldquo;<a href="https://developer.mozilla.org/en/Canvas_tutorial" target="_blank" rel="noopener">Canvas Tutorial</a><br>&rdquo;，了解更多 Canvas 绘图细节。<br>            <br><br></li><br><li><br>                如果对 Canvas 标准感兴趣可以参看完整的 <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#the-canvas-element" target="_blank" rel="noopener">Canvas API 标准</a><br>。<br>            <br><br></li><br><li><br>            关于 Cufon 的完整 API 参考，读者可见 <a href="http://wiki.github.com/sorccu/cufon/api" target="_blank" rel="noopener">http://wiki.github.com/sorccu/cufon/api</a><br>。<br>            <br><br></li><br><li><br>                <a href="https://developer.mozilla.org/en/HTML/Canvas" target="_blank" rel="noopener">MDC网站</a><br>上有丰富的Canvas资料。<br>            <br><br></li><br><li><br>                本例中的UI设计是部分参考了<a href="http://www.flickr.com/" target="_blank" rel="noopener">Flickr</a><br>的界面，但它是用Flash实现的，而我们用纯HTML实现的。<br>            <br><br></li><br><li><br>                developerWorks上有一系列文章关于HTML的未来: 《<a href="http://www.ibm.com/developerworks/cn/xml/x-futhtml1/" target="_blank" rel="noopener">HTML 的未来</a><br>》<br>            <br><br></li><br><li>developerWorks <a href="http://www.ibm.com/developerworks/cn/offers/techbriefings/" target="_blank" rel="noopener">技术活动</a><br>和<a href="http://www.ibm.com/developerworks/cn/swi/" target="_blank" rel="noopener">网络广播</a><br>：随时关注 developerWorks 技术活动和网络广播。<br><br><br></li><br><li><br>            <a href="http://www.ibm.com/developerworks/cn/web/" target="_blank" rel="noopener">developerWorks Web development<br>               专区</a><br>：通过专门关于 Web 技术的文章和教程，扩展您在网站开发方面的技能。</li><br></ul><br><br><br><br><br><p><a name="author"><span class="atitle">关于作者</span><br></a><br></p><br><table style="width: 100%;" border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td colspan="3"><img src="http://www.ibm.com/i/c.gif" alt="" width="100%" height="5"><br></td><br></tr><br><tr align="left" valign="top"><br><td></td><br><td><img src="http://www.ibm.com/i/c.gif" alt="" width="4" height="5"><br></td><br><td width="100%"><br><p>颜林，目前是 IBM 中国软件开发实验室的软件工程师，从事 Mac OS X 平台下的自动化测试工作。技术兴趣包括 Eclipse ，Mac OS X 开发，Linux 开发，Open Source。</p><br></td><br></tr><br></tbody><br></table><br></td><br></tr><br></tbody><br></table>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/blog/tags/HTML/" rel="tag"># HTML</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/blog/cjcuj6j1u004pl6rq1wgjs5h5/" rel="next" title="2009年度最佳jQuery插件">
                <i class="fa fa-chevron-left"></i> 2009年度最佳jQuery插件
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/blog/cjcuj6j1i0043l6rqxoxgjkc7/" rel="prev" title="35个你也许不知道的Google开源项目">
                35个你也许不知道的Google开源项目 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Vanessa</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/blog/archives/">
              
                  <span class="site-state-item-count">874</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">224</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Vanessa</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/blog/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/blog/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/blog/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/blog/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/blog/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/blog/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
