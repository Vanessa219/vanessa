<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/blog/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/blog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/blog/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/blog/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="JSF," />










<meta name="description" content="&amp;nbsp;级别： 中级Dan Allen (dan.allen@mojavelinux.com), 高级 Java 工程师, CodeRyte, Inc.2007 年  6 月  04 日借助 Seam 开发有状态的 CRUD 应用程序是件轻而易举的事情。在 无缝 JSF系列文章的第二篇中，Dan Allen 向您展示如何使用 Java?Server Faces (JSF) 和 Seam 为基于">
<meta name="keywords" content="JSF">
<meta property="og:type" content="article">
<meta property="og:title" content="Seam - 无缝集成 JSF，第 2 部分: 借助 Seam 进行对话">
<meta property="og:url" content="https://vanessa.js.org/blog/cjcujzjho019zxwrq4hzbi30s/index.html">
<meta property="og:site_name" content="Vanessa">
<meta property="og:description" content="&amp;nbsp;级别： 中级Dan Allen (dan.allen@mojavelinux.com), 高级 Java 工程师, CodeRyte, Inc.2007 年  6 月  04 日借助 Seam 开发有状态的 CRUD 应用程序是件轻而易举的事情。在 无缝 JSF系列文章的第二篇中，Dan Allen 向您展示如何使用 Java?Server Faces (JSF) 和 Seam 为基于">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/v14/rules/blue_rule.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/v14/icons/u_bold.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/v14/rules/blue_rule.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/v14/icons/u_bold.gif">
<meta property="og:image" content="http://www.ibm.com/i/v14/rules/blue_rule.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/v14/icons/u_bold.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/v14/rules/blue_rule.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/v14/icons/u_bold.gif">
<meta property="og:image" content="http://www.ibm.com/i/v14/rules/blue_rule.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/v14/icons/u_bold.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/v14/rules/blue_rule.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/v14/icons/u_bold.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/v14/rules/blue_rule.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/v14/icons/u_bold.gif">
<meta property="og:image" content="http://www.ibm.com/i/v14/rules/blue_rule.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/v14/icons/u_bold.gif">
<meta property="og:image" content="http://www.ibm.com/i/v14/rules/blue_rule.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/v14/icons/u_bold.gif">
<meta property="og:image" content="http://www.ibm.com/i/v14/rules/blue_rule.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/v14/icons/u_bold.gif">
<meta property="og:image" content="http://www.ibm.com/i/v14/rules/blue_rule.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/v14/icons/u_bold.gif">
<meta property="og:image" content="http://www.ibm.com/i/v14/rules/blue_rule.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/v14/icons/u_bold.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/v14/icons/fw.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/developerworks/i/p-dallen.jpg">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:updated_time" content="2018-01-23T13:26:13.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Seam - 无缝集成 JSF，第 2 部分: 借助 Seam 进行对话">
<meta name="twitter:description" content="&amp;nbsp;级别： 中级Dan Allen (dan.allen@mojavelinux.com), 高级 Java 工程师, CodeRyte, Inc.2007 年  6 月  04 日借助 Seam 开发有状态的 CRUD 应用程序是件轻而易举的事情。在 无缝 JSF系列文章的第二篇中，Dan Allen 向您展示如何使用 Java?Server Faces (JSF) 和 Seam 为基于">
<meta name="twitter:image" content="http://www.ibm.com/i/c.gif">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://vanessa.js.org/blog/cjcujzjho019zxwrq4hzbi30s/"/>





  <title>Seam - 无缝集成 JSF，第 2 部分: 借助 Seam 进行对话 | Vanessa</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/blog/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Vanessa</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/blog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/blog/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://vanessa.js.org/blog/blog/cjcujzjho019zxwrq4hzbi30s/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Vanessa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vanessa">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Seam - 无缝集成 JSF，第 2 部分: 借助 Seam 进行对话</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2008-11-26T08:32:00+08:00">
                2008-11-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>&nbsp;<br><table width="100%" border="0" cellpadding="0" cellspacing="0"><tbody><tr valign="top"><td width="10"><img alt="" src="http://www.ibm.com/i/c.gif" width="10" height="1"></td><td width="100%"><br><p>级别： 中级</p><p><a href="http://www.ibm.com/developerworks/cn/java/j-seam2/#author" target="_blank" rel="noopener">Dan Allen</a> (<a href="mailto:dan.allen@mojavelinux.com?subject=%E5%80%9F%E5%8A%A9%20Seam%20%E8%BF%9B%E8%A1%8C%E5%AF%B9%E8%AF%9D" target="_blank" rel="noopener">dan.allen@mojavelinux.com</a>), 高级 Java 工程师, CodeRyte, Inc.<br></p><p>2007 年  6 月  04 日</p><blockquote>借助 Seam 开发有状态的 CRUD 应用程序是件轻而易举的事情。在 <a href="http://www.ibm.com/developerworks/cn/java/j-seam/" target="_blank" rel="noopener">无缝 JSF</a><br>系列文章的第二篇中，Dan Allen 向您展示如何使用 Java?Server Faces (JSF) 和 Seam 为基于 Web<br>的高尔夫课程目录开发创建、读取、更新和删除用例。在此过程中，他突出强调了 Seam 对 JSF 生命周期的两项增强功能 —— 也就是<br>conversation 作用域和通过自定义 Java 5 注释进行配置 —— 并解释了其能够降低服务器负载和缩减开发时间的原因。</blockquote><!--START RESERVED FOR FUTURE USE INCLUDE FILES--><!-- include java script once we verify teams wants to use this and it will work on dbcs and cyrillic characters --></td></tr></tbody></table></p>
<!--END RESERVED FOR FUTURE USE INCLUDE FILES-->
<pre><code>&lt;p&gt;在这个分为三部分
</code></pre><p>的系列文章的第一篇中介绍了 Seam，它是既能显著增强 JSF 功能又能实现基于组件的架构的应用程序框架。在这篇文章中，我解释了 Seam<br>和其他经常与 JSF 结合使用的 Web 框架的不同之处，展示了向现有 JSF 应用程序添加 Seam 是多么轻松，最后概述了 Seam 对<br>JSF 应用程序生命周期的增强，同时还涉及到有状态的对话、工厂组件以及使用注释进行隐秘配置。</p><br>            <p>尽管这篇文章可能引发了您对 Seam 的兴趣，但是您可能无法确信它能够改善 JSF 开发体验。集成一组新工具通常比阅读它复杂得多，并且有时候并不值得。在<i>无缝 JSF</i><br>系列文章的第二篇文章中，您将亲自发现 Seam 是否能够实现其简化 JSF 开发的承诺。在使用 Seam 构建执行标准 CRUD<br>操作的简单应用程序之后，我敢肯定您会认为 Seam 是对 JSF 框架的必要扩展。结果，Seam 还能帮助降低数据库层有限资源的负载。</p><br>            <table width="40%" align="right" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td width="10"><img alt="" src="http://www.ibm.com/i/c.gif" width="10" height="1"></td><td><table width="100%" border="1" cellpadding="5" cellspacing="0"><tbody><tr><td bgcolor="#eeeeee"><br>                <a name="aboutseries"><b>关于本系列</b></a><br><br>                <a href="http://www.ibm.com/developerworks/cn/java/j-seam/" target="_blank" rel="noopener">无缝 JSF</a> 讲述了 Seam 是真正适合 JSF 的第一个应用程序框架，能够修正其他扩展框架无法修正的主要弱点。阅读该系列的文章，然后自己判断 Seam 是不是对 JSF 的适当补充。<br></td></tr></tbody></table></td></tr></tbody></table><br>            <p><a name="N10084"><span class="atitle">Open 18 应用程序</span></a></p><br>            <p><br>                <a href="http://www.ibm.com/developerworks/cn/java/j-seam2/#downloads" target="_blank" rel="noopener">Open 18</a><br>是基于 Web<br>的应用程序，允许用户管理一列曾经体验过的高尔夫课程，并记录每个场次的分数。为了体现本讨论的目的，该应用程序的范围仅限于管理高尔夫课程目录。第一个<br>屏幕展现了已经输入的课程列表，并列出各个课程的一些相关字段，如课程名称、地点和专卖店的电话号码。用户可以从该处查看完整的课程详细内容、添加新课<br>程、编辑现有课程，最终还可以删除课程。</p><br>            <p>在讲述如何使用 Seam 为 Open 18<br> 应用程序开发用例时，我重点讲述它如何简化代码，自动管理一系列请求期间的状态，并对输入数据<br>执行数据模型验证。</p><p></p>
<pre><code>&lt;p&gt;该系列文章的目标之一是证明 Seam 可以集成到现有的任何 JSF 应用程序，并且不需要转换到
</code></pre><p>Enterprise JavaBeans (EJB) 3。因此，Open 18 应用程序并不依靠 Seam 的 JPA <code>EntityManager</code> 集成进行事务型数据库访问，也不依靠 EBJ3 有状态会话 bean 进行状态管理。（<a href="http://www.ibm.com/developerworks/cn/java/j-seam2/#resources" target="_blank" rel="noopener">Seam 附带的示例</a> 大多都使用了这两项技术。）Open 18 设计为使用无状态的分层架构。服务层和数据访问<br>(DAO) 层使用 Spring 框架绑定到一起。我相信<br>由于 Spring 在 Web 应用程序领域的普遍性，该设计是切实可行的选择。该应用程序展示了如何通过使用<br> conversation 作用域将有状态的行为引入到 JSF 托管的 bean。记住这些 bean 是简单的 POJO。</p><br>            <p>您可以 <a href="http://www.ibm.com/developerworks/cn/java/j-seam2/#download" target="_blank" rel="noopener">下载 Open 18<br>源文件</a> 以及 <a href="http://www.ibm.com/developerworks/cn/java/j-seam2/#resources" target="_blank" rel="noopener">Maven 2</a>，以编译并运行样例代码。为了使您快速入门，我已经将该应用程序配置为使用<br>Seam 和 Spring-JSF 集成。如果想要在自己的项目中设置 Seam，可以<br>在 <a href="http://www.ibm.com/developerworks/cn/java/j-seam1/index.html" target="_blank" rel="noopener">本系列第一篇文章</a> 中找到完整的操作指导。请参见 <a href="http://www.ibm.com/developerworks/cn/java/j-seam2/#resources" target="_blank" rel="noopener">参考资料</a> 了解关于集成 JSF 和<br>Spring 的更多信息。</p><br>            <p><a name="N100B2"><span class="smalltitle">两个容器的故事</span></a></p><p></p>
<pre><code>&lt;p&gt;构建利用 Spring 框架的 JSF 应用程序的第一个步骤
</code></pre><p>是配置 JSF，使其可以访问 Spring<br>容器中的 bean。<i>spring-web</i> 包是 Spring 发布的一部分，附带有自定义 JSF 变量解析器，可构建此桥梁。<br>首先，Spring 解析器委托给 JSF 实现附带的本地解析器。本地解析器尝试将值绑定引用（如 <code>#{courseManager}</code>）与 JSF 容器中的托管 bean 相匹配。<br>该 bean 名称是由 <code>#{}</code> 表达式分隔符之间的字符组成的，<br>在这个例子中为 <i>courseManager</i>。如果该查找未能发现匹配，自定义解析器就会检查 Spring 的<br><code>WebApplicationContext</code>，以查找带有匹配<br><code>id</code> 属性的 Spring bean。请记住 Seam 是 JSF 框架的扩展，<br>因此 JSF 可以访问的任何变量也可以被 Seam 访问。</p><br>            <p>Spring 变量解析器是使用变量解析器节点在 faces-config.xml 文件中<br>配置的，如清单1所示：</p><br>            <br><a name="listing1"><b>清单 1. 配置 spring 变量解析器</b></a><br><table width="100%" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code-outline"><pre class="displaycode">                <br>&lt;variable-resolver&gt;<br>  org.springframework.web.jsf.DelegatingVariableResolver<br>&lt;/variable-resolver&gt;<br></pre></td></tr></tbody></table><br><br>            <br><table width="100%" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><img src="http://www.ibm.com/i/v14/rules/blue_rule.gif" alt="" width="100%" height="1"><br><img alt="" src="http://www.ibm.com/i/c.gif" width="8" border="0" height="6"></td></tr></tbody></table><table class="no-print" align="right" cellpadding="0" cellspacing="0"><tbody><tr align="right"><td><img src="http://www.ibm.com/i/c.gif" alt="" width="100%" height="4"><br><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td valign="middle"><img src="http://www.ibm.com/i/v14/icons/u_bold.gif" alt="" width="16" border="0" height="16"><br></td><td valign="top" align="right"><a href="http://www.ibm.com/developerworks/cn/java/j-seam2/#main" class="fbox" target="_blank" rel="noopener"><b>回页首</b></a></td></tr></tbody></table></td></tr></tbody></table><br><br><p><a name="N100DE"><span class="atitle">Seam 的上下文组件</span></a></p><br>            <p>为<br>了体现本文的目的，我假设基于<br>Spring 的服务层是不证自明的。除了 JSF-Spring<br>集成层之外 —— 该层负责向 JSF 公开 Spring bean<br>（因此也向 Seam 公开该 bean），并没有深入地使用 Spring。服务层对象将作为无状态的接口对待，CRUD<br>操作可以委托给该接口。解决这些应用程序细节之后，就可以自由地重点研究 Seam 如何将托管 bean<br>转换成有状态的组件，这些组件明确其在促进用户与应用程序<br>交互方面的角色。</p><br>            <p>通过创建名为 <code>courseAction</code> 的<br>支持<br>bean 来支持管理高尔夫课程目录的视图，就开始开发 Open 18 应用程序。<br>该托管 bean 公开一个高尔夫课程对象集合，然后对管理这些实例的操作做出响应。<br>这些数据的持久化委托给基于 Spring 的<br>服务层。</p><br>            <p>在典型的 JSF 应用程序中，使用托管 bean 工具来<br>注册 <code>CourseAction</code> bean，然后借助其委托对象（或 “依赖项”）注入该 bean。为此，必须打开<br>faces-config.xml 文件，然后使用该 bean 的名称和类添加新的 <code>managed-bean</code><br>节点，如清单 2 所示。通过使用值绑定表达式<br>添加引用其他托管 bean 的子 <code>managed-property</code> 节点，指定要向该类的属性中注入的依赖项。<br>在这个例子中，惟一的<br>依赖项是无状态的服务对象 <i>courseManager</i>，它是使用来自 Appfuse 项目的 <code>GenericManager</code> 类实现的（请参见 <a href="http://www.ibm.com/developerworks/cn/java/j-seam2/#resources" target="_blank" rel="noopener">参考资料</a>）。</p><br>            <br><a name="listing2"><b>清单 2. 作为 JDF 托管 bean 定义的 CourseAction</b></a><br><table width="100%" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code-outline"><pre class="displaycode">                <br>&lt;managed-bean&gt;<br>  &lt;managed-bean-name&gt;courseAction&lt;/managed-bean-name&gt;<br>  &lt;managed-bean-class&gt;com.ibm.dw.open18.CourseAction&lt;/managed-bean-class&gt;<br>  &lt;managed-property&gt;<br>    &lt;property-name&gt;courseManager&lt;/property-name&gt;<br>    &lt;value&gt;#{courseManager}&lt;/value&gt;<br>  &lt;/managed-property&gt;<br>&lt;/managed-bean&gt;<br></pre></td></tr></tbody></table><br><br>            <p><a name="N10112"><span class="smalltitle">注释简化了 XML！</span></a></p><br>            <p>现在您想起了使用本地 JSF 方法<br>定义托管 bean 有多麻烦，请忘记曾经看到 managed-bean<br>XML 声明 —— 因为您不再需要它了！在 <i>Seam</i> 构建的<br>应用程序中，bean 仅仅是使用 Java 5 注释声明的。Seam<br>将这些 bean 称为<i>上下文组件</i>。尽管您可能觉得该术语<br>很深奥，但是它只是描述一个组件（或命名实例）与给定的作用域（或称为上下文）有关。</p><p></p>
<pre><code>&lt;p&gt;Seam 在为上下文组件分配的作用域的生命期内对该组件进行管理。
</code></pre><p>Seam 组件更像 Spring bean，而不是 JSF<br>托管 bean，这是因为它们插入到复杂的、面向方面的框架。<br>在功能方面，Seam 框架远胜于 JSF 的基本控制反转 (IOC) 容器。<br>观察清单 3 中 <code>courseAction</code> 的声明。<code>CourseAction</code> 类被重构为利用 Seam 的注释。</p><br>            <br><a name="listing3"><b>清单 3. 作为 Seam 组件定义的 CourseAction</b></a><br><table width="100%" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code-outline"><pre class="displaycode">                <br>@Name(“courseAction”)<br>public class CourseAction {<br>    @In(“#{courseManager}”)<br>    private GenericManager&lt;Course, Long&gt; courseManager;<br>}<br></pre></td></tr></tbody></table><br><br>            <table width="40%" align="right" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td width="10"><img alt="" src="http://www.ibm.com/i/c.gif" width="10" height="1"></td><td><table width="100%" border="1" cellpadding="5" cellspacing="0"><tbody><tr><td bgcolor="#eeeeee"><br>                <a name="N10138"><b>与 Spring 的深入集成</b></a><br><br>自版本 1.2 起，Seam 开始包括 Spring 的自定义 namespace handler，它允许<br>将 Spring bean 公开为 Seam 组件。向 Spring bean<br>定义添加 <code>&lt;seam:component /&gt;</code> 标记，<br>允许您以基本格式使用 <code>@In</code><br>注释（来自 <a href="http://www.ibm.com/developerworks/cn/java/j-seam2/#listing3" target="_blank" rel="noopener">清单 3</a>），而不必<br>显式指定值绑定表达式。在这个例子中，Seam<br>会将该属性的名称与 Seam 组件相匹配，现在搜索中包括公开为 Seam 组件的 Spring<br>bean。请参见 <a href="http://www.ibm.com/developerworks/cn/java/j-seam2/#resources" target="_blank" rel="noopener">参考资料</a> 了解有关 Seam 1.2 新特性的更多信息。<br></td></tr></tbody></table></td></tr></tbody></table><p></p>
<pre><code>&lt;p&gt;注意所有 XML 语句都被去掉了！总之，这就是
</code></pre><p>Seam 注释的美妙之处。类的 @Name 注释指导 Seam 的变量解析器处理名称与<br>注释中的值相匹配的变量请求。然后 Seam<br>实例化这个类的实例，注入<br><code>@In</code> 注释指派的任何依赖项，然后假借该变量名公开<br>该实例。使用清单 3 作为示例，Seam 创建了 <code>CourseAction</code> 类实例，将 <code>courseManager</code> Spring bean 注入<code>courseManager</code> 属性，然后在收到<br>对变量 <code>courseAction</code> 的请求时返回该实例。额外<br>的好处是，该 bean 的配置接近于代码，因此对继承代码库的新开发人员来<br>说更加透明（甚至对于您这样只学了 6 个月的人来说也是如此）。</p><br>            <p><br>                <code>@In</code> 注释告知 Seam 将绑定表达式 <code>#{courseManager}</code><br>的值注入到定义它的属性。安装 JSF-Spring 集成之后，<br>该表达式解析成 Spring bean 配置中定义的名为 <code>courseManager</code> 的 bean。</p><br>            <br><table width="100%" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><img src="http://www.ibm.com/i/v14/rules/blue_rule.gif" alt="" width="100%" height="1"><br><img alt="" src="http://www.ibm.com/i/c.gif" width="8" border="0" height="6"></td></tr></tbody></table><table class="no-print" align="right" cellpadding="0" cellspacing="0"><tbody><tr align="right"><td><img src="http://www.ibm.com/i/c.gif" alt="" width="100%" height="4"><br><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td valign="middle"><img src="http://www.ibm.com/i/v14/icons/u_bold.gif" alt="" width="16" border="0" height="16"><br></td><td valign="top" align="right"><a href="http://www.ibm.com/developerworks/cn/java/j-seam2/#main" class="fbox" target="_blank" rel="noopener"><b>回页首</b></a></td></tr></tbody></table></td></tr></tbody></table><br><br><p><a name="N10175"><span class="atitle">准备课程列表</span></a></p><p></p>
<pre><code>&lt;p&gt;既然已经准备就绪，就可以继续研究第一个用例。
</code></pre><p>在 Open 18 应用程序的开始屏幕中，向用户提供了<br>当前存储在数据库中的所有课程列表。<br>借助 <code>h:dataTable</code> 组件标记，<br>清单 4 中的页面定义相当直观，并且不允许任何 Seam 特有的元素：</p><br>            <br><a name="listing4"><b>清单 4. 初始课程列表视图</b></a><br><table width="100%" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code-outline"><pre class="displaycode">                <br>&lt;h2&gt;Courses&lt;/h2&gt;<br>&lt;h:panelGroup rendered=”#{courseAction.courses.rowCount eq 0}”&gt;<br>  No courses found.<br>&lt;/h:panelGroup&gt;<br>&lt;h:dataTable id=”courses” var=”_course” value=”#{courseAction.courses}”<br>  rendered=”#{courseAction.courses.rowCount gt 0}”&gt;<br>  &lt;!– column definitions go here –&gt;<br>&lt;/h:dataTable&gt;<br></pre></td></tr></tbody></table><br><br>            <p>Java 代码可能有点难懂。清单 5 展示了如何使用本地 JSF 在作用域为该请求的支持 bean 中准备一个课程集合。为了简便起见，<br>去掉了注入的 Spring bean。</p><br>            <br><a name="listing5"><b>清单 5. 作为 DataModel 公开课程</b></a><br><table width="100%" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code-outline"><pre class="displaycode">                <br>public class CourseAction {<br>    // …<br><br>    private DataModel coursesModel = new ListDataModel();<br><br>    public DataModel getCourses() {<br>        System.out.println(“Retrieving courses…”);<br>        coursesModel.setWrappedData(courseManager.getAll());<br>        return coursesModel;<br>    }<br>    <br>    public void setCourses(DataModel coursesModel) {<br>        this.coursesModel = coursesModel;<br>    }<br>}<br></pre></td></tr></tbody></table><br><p></p>
<pre><code>&lt;p&gt;清单 5 中的 Java 代码看起来相当直观，不是吗？下面研究 JSF
</code></pre><p>使用支持 bean 时带来的性能问题。<br>提供实体列表时，您可能使用两种方法之一。<br>第一种是应用条件逻辑呈现至少包含一项的集合所支持的 <code>h:dataTable</code><br>，第二种是显示一条信息型消息，声明找不到任何实体。<br>要做出决定，可能需要咨询 <code>#{courseAction.courses}</code>，然后再对支持 bean 调用<br>相关的 getter 方法。</p><br>            <p>如果加载截至目前所开发的页面，然后查看最终<br>的服务器日志输出，就会看到：</p><br>            <table width="100%" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code-outline"><pre class="displaycode">Retrieving courses…<br>Retrieving courses…<br>Retrieving courses…<br></pre></td></tr></tbody></table><br><br>            <p>那么兄弟！如果您将这些代码投入生产，最好能<br>找到一个 DBA 找不到的安全隐藏点！这类代码执行对于数据库来说是个负累。<br>更糟的是，回发时情况会恶化，此时可能发生额外的冗余数据库调用。</p><br>            <p><a name="N101AF"><span class="smalltitle">让数据库休息下！</span></a></p><p></p>
<pre><code>&lt;p&gt;如果曾经使用 JSF 开发过应用程序，就会了解盲目地
</code></pre><p>在 getter 方法中获取数据非常不妥。为什么？<br>因为在典型的 JSF 执行生命周期中，会多次调用 getter 方法。<br>工作区尝试通过委托对象使数据检索过程与后续的数据访问过程相<br>隔离。其目的是避免每次咨询支持 bean 的访问函数时<br>带来运行查询的计算成本。解决方案包括<br>在构造函数中初始化 <code>DataModel</code>（<br>静态块），或 “init” 托管属性；在该 bean 的<br>私有属性中缓存结果；使用 <code>HttpSession</code> 或作用域为会话的支持 bean；并依赖<br>另一层 O/R 缓存机制。</p><br>            <p>清单 6 显示了另一种选择：使用作用域为该请求的 bean 的私有属性<br>临时缓存查找结果。您会发现，<br>这至少能够在页面呈现阶段消除冗余获取，<br>但是当该 bean 在后续页面超出作用域时，仍然会丢弃该缓存。</p><br>            <br><a name="listing6"><b>清单 6. 作为 DataModel 公开课程，仅获取一次</b></a><br><table width="100%" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code-outline"><pre class="displaycode">                <br>public class CourseAction {<br>    // …<br><br>    private DataModel coursesModel = null;<br><br>    public DataModel getCourses() {<br>        if (coursesModel == null) {<br>            System.out.println(“Retrieving courses…”);<br>            coursesModel = new ListDataModel(courseManager.getAll());<br>        }<br>        return coursesModel;<br>    }<br>    <br>    public void setCourses(DataModel coursesModel) {<br>        this.coursesModel = coursesModel;<br>    }<br>}<br></pre></td></tr></tbody></table><br><br>            <p>清单 6 中的方法只是切断数据检索和数据访问的尝试之一。<br>无论您制定什么样的解决方案，保持数据<br>的可用性直到不再需要是避免冗余数据获取的关键。<br>幸运的是，这类上下文状态管理正是 Seam 所擅长的！</p><br>            <br><table width="100%" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><img src="http://www.ibm.com/i/v14/rules/blue_rule.gif" alt="" width="100%" height="1"><br><img alt="" src="http://www.ibm.com/i/c.gif" width="8" border="0" height="6"></td></tr></tbody></table><table class="no-print" align="right" cellpadding="0" cellspacing="0"><tbody><tr align="right"><td><img src="http://www.ibm.com/i/c.gif" alt="" width="100%" height="4"><br><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td valign="middle"><img src="http://www.ibm.com/i/v14/icons/u_bold.gif" alt="" width="16" border="0" height="16"><br></td><td valign="top" align="right"><a href="http://www.ibm.com/developerworks/cn/java/j-seam2/#main" class="fbox" target="_blank" rel="noopener"><b>回页首</b></a></td></tr></tbody></table></td></tr></tbody></table><br><br><p><a name="N101D0"><span class="atitle">上下文状态管理</span></a></p><br>            <p>Seam 使用工厂模式初始化非组件对象和<br>集合。一旦初始化数据之后，Seam 就可以将生成的对象放到<br>一个可用的作用域中，然后就可以在其中反复读取，而不再需要借助工厂方法<br>。这个特殊的上下文<br>就是 <i>conversation 作用域</i>。conversation 作用域提供了<br>在一组明确定义的请求期间临时维护状态的方法。</p><br>            <p>直到最近，也很少有 Web 应用程序架构提供<br>任何类型的能够表现对话的构造。<br>现有的任何上下文都没有提供<br>合适的粒度水平，用于处理多请求操作。<br>您会发现，对话提供了一种方式，可以防止短期存储丢失，<br>而短期存储丢失在 Web 应用程序中很常见，并且还是滥用数据库的根本原因。结合工厂组件模式使用对话使得在合适时咨询数据库成为可能，而不是为了重新获取应用程序未能跟踪的数据。</p><br>            <table width="40%" align="right" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td width="10"><img alt="" src="http://www.ibm.com/i/c.gif" width="10" height="1"></td><td><table width="100%" border="1" cellpadding="5" cellspacing="0"><tbody><tr><td bgcolor="#eeeeee"><br>                <a name="N101E2"><b>双射</b></a><br><br>                <i>双射</i>是 Seam 对依赖项注入概念的扩展。<br>除了接收上下文变量来设置组件属性值之外，<br>双射允许将组件属性值推出目标上下文，<br>该操作称为 <i>outjecting</i>。双射与依赖项注入的不同之处<br>在于它是动态的、上下文相关的并且是双向的。<br>也就是说，双射是动态上一致的，即调用组件时进行导入和导出值操作。因此，<br>双射更适合有状态的组件，如 Web 应用程序中使用的<br>那些组件。<br></td></tr></tbody></table></td></tr></tbody></table><br>            <p><a name="N101EE"><span class="smalltitle">使用对话防止存储丢失</span></a></p><br>            <p>要完成一项任务，应用程序常常必须指导用户浏览一系列屏幕。<br>该过程通常需要多次向服务器发出 post，<br>或者是由用户直接提交表单，或者通过 Ajax 请求。<br>在任何一种情况下，都应该能够在用例期间通过维护服务器端对象的状态<br>跟踪该应用程序。对话相当于逻辑工作单元。它<br>允许您借助确定的起始点和结束点在单个浏览器窗口中为单个用户创建单<br>独的上下文。用户与该应用程序的交互状态是针对整个对话维护的。</p><p></p>
<pre><code>&lt;p&gt;Seam 提供了两类对话：临时对话和长时间运行的对话。&lt;i&gt;临时对话&lt;/i&gt; 存在于整个请求过程，包括重定向。
</code></pre><p>这项功能解决了 JSF 开发过程中的一项难题，<br>即重定向将无意中丢弃存储在<br><code>FacesContext</code>（如 <code>FacesMessage</code> 实例）中的信息。临时对话是<br>Seam 中的标准操作模式：您可以免费获得这些模式。这意味着<br>在经过重定向之后取出的任何值仍然能够存在，而不需要您执行额外的工作。<br>这项功能是安全网，允许 Seam 自由地在任意适当的时候使用重定向。</p><p></p>
<pre><code>&lt;p&gt;相比之下，&lt;i&gt;长期运行的对话&lt;/i&gt; 能够在一系列明确定义的
</code></pre><p>请求期间保持作用域中的变量。您可以在配置文件中定义对话边界，借助<br>注释进行声明，也可以借助 Seam API，通过编程对其进行控制。<br>长期运行的对话有点像小会话，隔离在自己的浏览器选项卡中（或窗口），<br>能够在对话结束或超时时自动清除。与对应的会话相比，conversation 作用域的<br>要点之一是：conversation 作用域将发生在同一应用程序屏幕上位于多个浏览器选项卡中<br>的活动分离开。简单地讲，使用对话消除了并发冲突的危险。（请参见 <a href="http://www.ibm.com/developerworks/cn/java/j-seam2/#resources" target="_blank" rel="noopener">参考资料</a> 阅读关于 Seam 如何隔离并发对话的详细讨论。）</p><p></p>
<pre><code>&lt;p&gt;Seam 对话是对 ad-hoc 会话管理方法的重大改进，后者是现场临时
</code></pre><p>准备的，或者是其他框架鼓励使用的。conversation 作用域的引入还解决了很多开发人员指出的<br>问题，即 JSF 使用对象打乱了 <code>HttpSession</code>，没有提供任何自动垃<br>圾回收 (GC) 机制。对话允许您创建有状态的组件，而不必使用<br><code>HttpSession</code>。借助 conversation 作用域，几乎不再<br>需要使用会话作用域，并且您可以更为随意地使用。<br></p><br>            <br><table width="100%" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><img src="http://www.ibm.com/i/v14/rules/blue_rule.gif" alt="" width="100%" height="1"><br><img alt="" src="http://www.ibm.com/i/c.gif" width="8" border="0" height="6"></td></tr></tbody></table><table class="no-print" align="right" cellpadding="0" cellspacing="0"><tbody><tr align="right"><td><img src="http://www.ibm.com/i/c.gif" alt="" width="100%" height="4"><br><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td valign="middle"><img src="http://www.ibm.com/i/v14/icons/u_bold.gif" alt="" width="16" border="0" height="16"><br></td><td valign="top" align="right"><a href="http://www.ibm.com/developerworks/cn/java/j-seam2/#main" class="fbox" target="_blank" rel="noopener"><b>回页首</b></a></td></tr></tbody></table></td></tr></tbody></table><br><br><p><a name="N10219"><span class="atitle">借助 Seam 创建对象</span></a></p><br>            <p>回到课程列表示例，这时该重构代码，以利用工厂模式。<br>目的是允许 Seam 管理课程集合，以便其在请求（包括重定向）期间保持可用。<br>如果希望 Seam 管理该集合，则必须使用合适的注释将创建过程交给 Seam。</p><p></p>
<pre><code>&lt;p&gt;Seam 使用构建函数实例化和装配组件。这些构建函数是在 bean 类中
</code></pre><p>通过注释声明的。实际上，您已经见到过其中一个例子：<br><code>@Name</code><br>注释。<code>@Name</code> 注释告知 Seam 使用默认的<br>类构造函数创建新实例。要构建自己的课程列表，您不希望使用组件实例，而是<br>使用对象集合。为此，您希望使用 <code>@Factory</code> 注释。<code>@Factory</code> 注释向已提取变量的创建过程<br>附加了一个方法，这是在注释的值中指定的，当该变量没有绑定任何值时就会使<br>用该方法。</p><br>            <p>在清单 7 中，工厂方法 <code>findCourses()</code>（位于 <code>CourseAction</code> 类）用于初始化<br><i>courses</i> 属性的值，该值是作为 <code>DataModel</code><br>提取到视图中的。该工厂方法通过将这项工作委托给服务层来实例化课程对象集合。</p><br>            <br><a name="listing7"><b>清单 7. 使用 DataModel 注释公开课程</b></a><br><table width="100%" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code-outline"><pre class="displaycode">                <br>@Name(“courseAction”)<br>public class CourseAction {<br>    // …<br><br>    @DataModel<br>    private List&lt;Course&gt; courses;<br>    <br>    @Factory(“courses”)<br>    public void findCourses() {<br>        System.out.println(“Retrieving courses…”);<br>        courses = courseManager.getAll();<br>    }<br>}<br></pre></td></tr></tbody></table><br><br>            <p>请注意，这里不存在 <code>getCourses()</code> 和<br><code>setCourses()</code>方法！借助 Seam，使用<br>标记着 <code>@DataModel</code> 注释的私有属性的名称和值将数据提取到视图中。<br>因此不需要属性访问函数。在这个方案中，<code>@DataModel</code> 注释执行两项功能。首先，它提取<i>或公开</i> 该属性，以便 JSF 变量解析器可以通过值绑定表达式 <code>#{courses}</code> 对它进行访问。<br>其次，它提供了手动在 <code>DataModel</code> 类型中包装课程列表的备选方式（如 <a href="http://www.ibm.com/developerworks/cn/java/j-seam2/#listing4" target="_blank" rel="noopener">清单 4</a> 中所示）。作为替代，Seam 自动在<br><code>DataModel</code> 实例中嵌入课程列表，以便其可以方便地<br>与 <code>UIData</code> 组件（如<br><code>h:dataTable</code>）一起使用。因此，支持 bean（<code>CourseAction</code>）成为简单的<br>POJO。然后由该框架处理 JSF 特有的细节。</p><br>            <p>清单 8 显示了该视图中发生的相应重构。<br>与 <a href="http://www.ibm.com/developerworks/cn/java/j-seam2/#listing5" target="_blank" rel="noopener">清单 5</a> 惟一的不同之处在于值绑定表达式。<br>利用 Seam 的提取机制时，使用缩写的值绑定表达式<br><code>#{courses}</code><br>，而不是通过 <code>#{courseAction.courses}</code> 咨询支持<br>bean 的访问方法。提取的变量直接放到该变量上下文中，不受其支持 bean 的约束。</p><br>            <br><a name="listing8"><b>清单 8. 使用提取的 DataModel 的课程列表视图</b></a><br><table width="100%" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code-outline"><pre class="displaycode">                <br>&lt;h2&gt;Courses&lt;/h2&gt;<br>&lt;h:panelGroup rendered=”#{courses.rowCount eq 0}”&gt;<br>  No courses found.<br>&lt;/h:panelGroup&gt;<br>&lt;h:dataTable id=”courses” var=”_course” value=”#{courses}”<br>  rendered=”#{courses.rowCount gt 0}”&gt;<br>  &lt;!– column definitions goes here –&gt;<br>&lt;/h:dataTable&gt;<br></pre></td></tr></tbody></table><br><br>            <p>现在再次访问该页面时，以下消息在控制台中只出现一次：</p><br>            <table width="100%" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code-outline"><pre class="displaycode"> Retrieving courses…</pre></td></tr></tbody></table><br><br>            <p>使用工厂构建函数以及临时 conversation 作用域能够在请求期间保持这些数据，<br>并确保变量 <i>courses</i> 仅实例化一次，而不管在视图中它被访问了多少次。</p><br>            <p><a name="N102A9"><span class="smalltitle">逐步分析创建方案</span></a></p><br>            <p>您可能想知道 <code>@Factory</code><br>注释什么时候起作用。<br>为了防止注释变得太神秘，我们将逐步分析刚刚描述的创建方案。可以按照图 1 中的序列图进行研究：</p><p></p>
<pre><code>    &lt;br&gt;&lt;a name=&quot;figure1&quot;&gt;&lt;b&gt;图 1. Seam 提取使用工厂方法初始化的 DataModel&lt;/b&gt;&lt;/a&gt;&lt;br&gt;
    &lt;img alt=&quot;Seam 工厂序列图&quot; src=&quot;http://www.ibm.com/developerworks/cn/java/j-seam2/factory-sequence.gif&quot; width=&quot;541&quot; height=&quot;387&quot;&gt;
&lt;br&gt;
&lt;p&gt;视图组件（如 &lt;code&gt;h:dataTable&lt;/code&gt;）依靠
</code></pre><p>值绑定表达式 <code>#{courses}</code><br>提供课程集合。本地 JSF 变量解析器首先查找与名称 <i>courses</i> 相匹配的<br>JSF 托管 bean。如果找不到任何匹配，Seam 就会收到解析该变量的请求。Seam<br>搜索其组件，然后发现在 <code>CourseAction</code><br>类中，<code>@DataModel</code><br>注释被指派给具有等价名称（<code>courses</code>）的属性。<br>然后如果不存在 <code>CourseAction</code> 类实例，则创建之。</p><br>            <p>如果 <code>courses</code> 属性的值为 <code>null</code>，Seam 就会再次使用该属性的名称作为键查找 <code>@Factory</code> 注释。<br>借助 <code>findCourses()</code> 方法找到匹配之后，Seam 调用它来初始化<br>该变量。最后作为 <i>courses</i> 提取该属性的值，将其包装到<br><code>DataModel</code> 实例。现在<br>JSF 变量解析器和视图就可以使用包装的值。任何<br>针对此上下文变量的后续请求都会返回已经准备好的课程集合。</p><br>            <p>既然已经清楚检索课程列表以及在 Seam 托管的上下文变量中维护该值的方法，<br>下面研究课程列表以外的内容。您已经准备好与课程目录进行交互。<br>在以下几节中，将使用显示单门课程详细内容（以及添加、编辑和删除课程）的功能，扩展 Open 18<br>应用程序。</p><br>            <br><table width="100%" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><img src="http://www.ibm.com/i/v14/rules/blue_rule.gif" alt="" width="100%" height="1"><br><img alt="" src="http://www.ibm.com/i/c.gif" width="8" border="0" height="6"></td></tr></tbody></table><table class="no-print" align="right" cellpadding="0" cellspacing="0"><tbody><tr align="right"><td><img src="http://www.ibm.com/i/c.gif" alt="" width="100%" height="4"><br><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td valign="middle"><img src="http://www.ibm.com/i/v14/icons/u_bold.gif" alt="" width="16" border="0" height="16"><br></td><td valign="top" align="right"><a href="http://www.ibm.com/developerworks/cn/java/j-seam2/#main" class="fbox" target="_blank" rel="noopener"><b>回页首</b></a></td></tr></tbody></table></td></tr></tbody></table><br><br><p><a name="N10300"><span class="atitle">实现 CRUD 的巧妙方式</span></a></p><p></p>
<pre><code>&lt;p&gt;遇到的第一项 CRUD 操作是显示从课程列表中选出的单门课程的详细内容。
</code></pre><p>JSF 规范实际上为您处理了一些数据选择收集工作。当从 <code>UIData</code> 组件（如<code>h:dataTable</code>）的<br>某行触发 <code>h:commandLink</code> 之类的操作时，在调用事件监听程序之前，<br>组件的当前行设置为与该事件相关的行。可以将当前行想象成一个指针，<br>在这个例子中，该指针固定在接受该操作的行。实际上，JSF 了解行操作与该行的底层数据有关。处理该操作时，JSF 帮助将这些数据放到上下文中。</p><br>            <p>JSF 本身允许您以两种方式访问支持被激活行的数据。<br>一种方式是使用 <code>DataModel#getRowData()</code> 方法检索该数据。另一种方法是<br>从对应于临时循环变量的值绑定中读取该数据，<br>该变量定义在组件标记的 <code>var</code><br>属性中。在第二种情况下，在事件处理期间将再次向变量解析器公开<br>临时循环变量（<i>_course</i>）。这两种访问形式最终都需要与<br>JSF<br> API 进行交互。</p><br>            <p>如果选择 <code>DataModel</code> API 作为行<br>数据入口点，那么必须将 <code>DataModel</code> 包装器对象公开为支持<br>bean 的属性，如 <a href="http://www.ibm.com/developerworks/cn/java/j-seam2/#listing4" target="_blank" rel="noopener">清单 4</a> 所示。另一方面，如果<br>选择通过值绑定访问行数据，则必须咨询<br>JSF 变量解析器。后一种方法还会将您与视图中使用的临时循环变量名称 <i>_course</i> 联系起来。</p><br>            <p>现在考虑 Seam 更抽象的获得所选数据的方法。Seam 允许您将针对 Seam 组件定义的 <code>@DataModel</code> 注释与 <code>@DataModelSelection</code><br>补充注释配对。在回发期间，Seam 自动检测该配对。然后将 <code>UIData</code> 组件的当前行数据注入指派了<br><code>@DataModelSelection</code> 注释的属性。该方法使支持 bean 与 JSF API<br>分离，因此使其返回 POJO 状态。</p><br>            <table width="40%" align="right" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td width="10"><img alt="" src="http://www.ibm.com/i/c.gif" width="10" height="1"></td><td><table width="100%" border="1" cellpadding="5" cellspacing="0"><tbody><tr><td bgcolor="#eeeeee"><br>                <a name="N1034B"><b>组件ID</b></a><br><br>为 JSF 组件标记的 <i>id</i> 属性指定值，总是不错的主意，命名容器的属性更是如此。<br>如果没有为组件指派 ID，JSF 实现就会生成隐秘的 ID。<br>拥有有意义的 ID 有助于调试或编写访问该 DOM 的<br>JavaScript。<br></td></tr></tbody></table></td></tr></tbody></table><br>            <p><a name="N10354"><span class="smalltitle">长期运行的对话</span></a></p><br>            <p>要确保回发时该课程列表仍然可用，并且<br>不必重新从数据库中获取该列表，就能呈现下一个响应，<br>则必须将当前的临时对话转变成长期运行的对话。</p><br>            <p>说服 Seam 将临时对话提升到长期运行对话的一种方式是<br>设置一个方法，使其在执行过程中驻留 <code>@Begin</code> 注释。还<br>必须将组件本身放到该 conversation 作用域中。通过在 <code>CourseAction</code><br>类定义<br>顶部添加 <code>@Scope(ScopeType.CONVERSATION)</code><br>注释，就可以实现。使用长期运行的对话，允许变量保持作用域直至对话结束，<br>而不仅仅是单个请求。对于 <code>UIData</code> 组件来说，这种跨多个请求的稳定性尤其重要。<br>（请参阅 <a href="http://www.ibm.com/developerworks/cn/java/j-seam1/index.html" target="_blank" rel="noopener">本系列第一篇文章</a> 中关于有状态组件的讨论，了解<br>数据不稳定可能对 <code>UIData</code><br>组件的列队执行事件所造成的问题。）</p><br>            <p>您希望允许用户从课程目录中选择单个课程。要实现这项功能，<br>在 <code>h:commandLink</code> 中包装各个课程的名称，<code>h:commandLink</code> 将方法绑定 <code>#{courseAction.selectCourse}</code> 指派成操作，<br>如清单 9 所示。当用户单击其中一个链接时，就会触发对支持 bean 的 <code>selectCourse()</code><br>方法的调用过程。由于 Seam 控制着注入过程，所以与该行有关的课程数据<br>将自动分配给带有 <code>@DataModelSelection</code><br>注释的属性。因此，不必执行任何查找，就能使用该属性，详细信息<br>如清单 10 所示。</p><br>            <br><a name="listing9"><b>清单 9. 添加命令链接以选择课程</b></a><br><table width="100%" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code-outline"><pre class="displaycode">                <br>&lt;h2&gt;Courses&lt;/h2&gt;<br>&lt;h:panelGroup rendered=”#{courses.rowCount eq 0}”&gt;<br>  No courses found.<br>&lt;/h:panelGroup&gt;<br>&lt;h:dataTable id=”courses” var=”_course” value=”#{courses}”<br>  rendered=”#{courses.rowCount gt 0}”&gt;<br>  &lt;h:column&gt;<br>    &lt;f:facet name=”header”&gt;Course Name&lt;/f:facet&gt;<br>    &lt;h:commandLink id=”select”<br>        action=”#{courseAction.selectCourse}” value=”#{_course.name}” /&gt;<br>  &lt;/h:column&gt;<br>  &lt;!– additional properties –&gt;<br>&lt;/h:dataTable&gt;</pre></td></tr></tbody></table><br><br>            <p>向提供数据选择的支持 bean 添加的内容主要是注释；<br>放到 conversation 作用域时，必须将该类序列化。</p><br>            <br><a name="listing10"><b>清单 10. 用于捕获所选课程的 DataModelSelection 注释</b></a><br><table width="100%" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code-outline"><pre class="displaycode">                <br>@Name(“courseAction”)<br>@Scope(ScopeType.CONVERSATION)<br>public class CourseAction implements Serializable {<br>    // …<br><br>    @DataModel<br>    private List&lt;Course&gt; courses;<br>  <br>    @DataModelSelection<br>    private Course selectedCourse;<br>    <br>    @Begin(join=true)<br>    @Factory(“courses”)<br>    public void findCourses() {<br>        System.out.println(“Retrieving courses…”);<br>        courses = courseManager.getAll();<br>    }<br>  <br>    public String selectCourse() {<br>        System.out.println(“Selected course: “ + selectedCourse.getName());<br>        System.out.println(“Redirecting to /courses.jspx”);<br>        return “/courses.jspx”;<br>    }<br>}</pre></td></tr></tbody></table><br><br>            <table width="40%" align="right" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td width="10"><img alt="" src="http://www.ibm.com/i/c.gif" width="10" height="1"></td><td><table width="100%" border="1" cellpadding="5" cellspacing="0"><tbody><tr><td bgcolor="#eeeeee"><br>                <a name="N103A7"><b>持久化上下文</b></a><br><p></p>
<pre><code>&lt;i&gt;持久化上下文&lt;/i&gt; 是 Seam 可以管理的上下文之一。
</code></pre><p>持久化上下文是借助 Hibernate 或 JPA 从数据库加载的所有对象的标识作用域和<br>内存缓存。与<br>Spring 提倡的无状态架构相比，Seam 的创建者推荐使用作用域为对话的组件，<br>并使该组件跨多个请求保留持久化上下文。无状态模型引入的问题是：<br>关闭持久化上下文时，所有加载的对象进入 “隔离” 状态，<br>无法再担保这些对象的标识是否正确。<br>结果导致数据库和开发人员不得不解决跨持久化上下文会话的对象是否相等。<br>本文中没有利用托管的持久化上下文。请参阅 <a href="http://www.ibm.com/developerworks/cn/java/j-seam2/#resources" target="_blank" rel="noopener">参考资料</a> 了解更多内容。</p></td></tr></tbody></table></td></tr></tbody></table><br>            <p><a name="N103B4"><span class="smalltitle">对话的优点</span></a></p><br>            <p>在 <a href="http://www.ibm.com/developerworks/cn/java/j-seam2/#listing10" target="_blank" rel="noopener">清单 10</a> 中可以看出，所有变量作用域是由 Seam 处理的。<br>当执行工厂方法来初始化课程集合时，Seam 遇到 <code>@Begin</code><br>注释，因此将该临时对话提升为长期运行的对话。<code>@DataModel</code><br>注释提取的变量采用其所有者组件的作用域。因此，<br>在对话期间，该课程集合保持可用。当遇到标记着 <code>@End</code> 注释的方法时，<br>对话结束。</p><br>            <p>单击某一行的课程名称时，Seam 使用支持该行的课程数据值<br>填充带有 <code>@DataModelSelection</code> 注释的属性。<br>然后触发操作方法 <code>selectCourse()</code>，导致在控制台上显示<br>所选课程的名称。最后，重新显示课程列表。<br>随后就会在控制台中看到：</p><br>            <table width="50%" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code-outline"><pre class="displaycode">Retrieving courses…<br>Selected course: Sample Course<br>Redirecting to /courses.jspx<br></pre></td></tr></tbody></table><br><br>            <p>借助 Seam，就不必在 faces-config.xml 中定义<br>导航规则，即映射每个操作的返回值。取而代之，Seam 检查<br>操作的返回值是不是有效的视图模板（技术上称之为<i>视图 id</i>），<br>并对其执行动态导航。这项功能能够使简单的应用程序保持简单，<br>还允许对更高级的用例使用声明式导航。请记住，<br>在这个例子中，Seam 在执行导航时发出了重定向命令。</p><br>            <p>如果需要通过声明结束对话，则可以使用 <code>@End(beforeRedirect=true)</code> 注释操作方法 <code>selectCourse()</code>，在这种情况下，<br>对话会在每次调用该方法后结束。<code>beforeRedirect</code> 属性确保在呈现下一<br>个页面之前清除对话上下文中的变量，这样能使临时对话的工作短路，<br>而在重定向时临时对话通常会填充这些值。<br>在这个方案中，在每次选中课程时开始数据准备过程。<br>执行完以上描述的同一事件序列之后，现在控制台将显示：</p><br>            <table width="100%" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code-outline"><pre class="displaycode">Retrieving courses…<br>Selected course: Sample Course<br>Redirecting to /courses.jspx<br>Retrieving courses…<br></pre></td></tr></tbody></table><br><br>            <br><table width="100%" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><img src="http://www.ibm.com/i/v14/rules/blue_rule.gif" alt="" width="100%" height="1"><br><img alt="" src="http://www.ibm.com/i/c.gif" width="8" border="0" height="6"></td></tr></tbody></table><table class="no-print" align="right" cellpadding="0" cellspacing="0"><tbody><tr align="right"><td><img src="http://www.ibm.com/i/c.gif" alt="" width="100%" height="4"><br><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td valign="middle"><img src="http://www.ibm.com/i/v14/icons/u_bold.gif" alt="" width="16" border="0" height="16"><br></td><td valign="top" align="right"><a href="http://www.ibm.com/developerworks/cn/java/j-seam2/#main" class="fbox" target="_blank" rel="noopener"><b>回页首</b></a></td></tr></tbody></table></td></tr></tbody></table><br><br><p><a name="N103F7"><span class="atitle">提取课程的详细内容</span></a></p><br>            <p>您尚未详细了解显示课程的用例。<code>@DataModelSelection</code> 注释负责<br>将当前行数据注入支持 bean 的实例变量，但是它不是在执<br>行该操作方法之后填充数据，使其可用于随后的视图。为此，<br>必须提取所选的值。</p><br>            <p>您已经看到一种注入形式，即 <code>@DataModel</code> 注释向要呈现的视图<br>公开一个对象集合。<code>@DataModel</code><br>注释对单个对象实例的补充是 <code>@Out</code> 注释。<code>@Out</code><br>注释仅仅获取该属性，并使用该属性自己的名称向变量解析器公开其值。<br>默认情况下，每次激活时，<code>@Out</code> 注释都需<br>要非 null 值。因为并非总是存在课程选择，如第一次显示课程列表时，<br>所以必须将所需的注释标记设置为 <i>false</i>，以表明该提取是有<br>条件的。</p><br>            <table width="40%" align="right" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td width="10"><img alt="" src="http://www.ibm.com/i/c.gif" width="10" height="1"></td><td><table width="100%" border="1" cellpadding="5" cellspacing="0"><tbody><tr><td bgcolor="#eeeeee"><br>                <a name="N10421"><b>命名循环变量</b></a><br><br>为 <code>h:dataTable</code> 选择临时循环变量名时，<br>必须谨慎，不能使其与其他提取变量发生冲突。在所有示例中，<br>我指定循环变量名称时使用了<i>下划线前缀</i>。该前缀不仅<br>可以防止与提取的课程发生冲突，还有助于说明该变量限定了作用域。<br>上下文变量存储在给定作用域的共享映射中，因此为其选择名称时<br>一定要谨慎！<br></td></tr></tbody></table></td></tr></tbody></table><br>            <p>默认情况下，<code>@Out</code> 注释反映了<br>用于确定上下文变量名称的属性名称。如果您认为更合适的话，<br>可以选择为提取的变量使用不同名称。因为课程数据将被提取<br>到 conversation 作用域，并且可能在后续的一些请求中使用，<br>所以该名称的 “所选” 特征失去了原来的意义。在这种情况下，<br>最好使用实体本身的名称。因此，<code>selectedCourse</code> 属性的推荐注释为 <code>@Out(value=”course”, required=false)</code>。</p><br>            <p>可以在新页面上显示课程详细内容，也可以<br>显示在同一页面的表格下面。为了演示的目的，在同一页面显示详细内容，同时限制要构造的视图数目。要在另一个页面中<br>访问提取的变量，不需要额外的工作或特殊技巧。</p><br>            <p><a name="N10440"><span class="smalltitle">修订过的支持 bean</span></a></p><br>            <p>与 <a href="http://www.ibm.com/developerworks/cn/java/j-seam2/#listing10" target="_blank" rel="noopener">该支持 bean 的上一个版本</a> 的差别不大，因此，清单 11 仅突出显示了两者的不同之处。<code>selectedCourse</code> 属性现在有两个注释。<code>selectCourse()</code> 方法也被稍加整理。<br>现在它在继续呈现视图之前重新提取该课程对象。在无状态的设计中，<br>必须确保完全由数据层填充对象，并且正确地初始化任何与显示其详细<br>内容有关的延迟加载。</p><br>            <br><a name="listing11"><b>清单 11. 将所选课程提取到视图</b></a><br><table width="100%" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code-outline"><pre class="displaycode">                <br>    // …<br><br>    @DataModelSelection<br>    @Out(value=”course”, required=false)<br>    private Course selectedCourse;<br>    <br>    public String selectCourse() {<br>        System.out.println(“Selected course: “ + selectedCourse.getName());<br>        // refetch the course, loading all lazy associations<br>        selectedCourse = courseManager.get(selectedCourse.getId());<br>        System.out.println(“Redirecting to /courses.jspx”);<br>        return “/courses.jspx”;<br>    }<br><br>    // …</pre></td></tr></tbody></table><br><br>            <p>其中大多数有趣的变化都发生在视图中，但是这些变化并不新奇。清单 12 显示了在选中某个课程时，呈现在 <code>h:dataTable</code><br>下面的详细内容面板：</p><br>            <br><a name="listing12"><b>清单 12. 有条件地为所选课程显示课程详细内容</b></a><br><table width="100%" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code-outline"><pre class="displaycode">                <br>&lt;h:panelGroup rendered=”#{course.id gt 0}”&gt;<br>  &lt;h3&gt;Course Detail&lt;/h3&gt;<br>  &lt;table class=”detail”&gt;<br>    &lt;tr&gt;<br>      &lt;th&gt;Course Name&lt;/th&gt;<br>      &lt;td&gt;#{course.name}&lt;/td&gt;<br>    &lt;/tr&gt;<br>    &lt;!– additional properties –&gt;<br>&lt;/h:panelGroup&gt;<br></pre></td></tr></tbody></table><br><br>            <br><table width="100%" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><img src="http://www.ibm.com/i/v14/rules/blue_rule.gif" alt="" width="100%" height="1"><br><img alt="" src="http://www.ibm.com/i/c.gif" width="8" border="0" height="6"></td></tr></tbody></table><table class="no-print" align="right" cellpadding="0" cellspacing="0"><tbody><tr align="right"><td><img src="http://www.ibm.com/i/c.gif" alt="" width="100%" height="4"><br><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td valign="middle"><img src="http://www.ibm.com/i/v14/icons/u_bold.gif" alt="" width="16" border="0" height="16"><br></td><td valign="top" align="right"><a href="http://www.ibm.com/developerworks/cn/java/j-seam2/#main" class="fbox" target="_blank" rel="noopener"><b>回页首</b></a></td></tr></tbody></table></td></tr></tbody></table><br><br><p><a name="N10470"><span class="atitle">重新注入课程</span></a></p><p></p>
<pre><code>&lt;p&gt;Open 18 应用程序最复杂的用例是创建和更新操作。
</code></pre><p>但是借助 Seam，实现起来并不困难。要完成这两项需求，<br>必须使用一个额外的注释：<code>@In</code>。将课程提取到呈现课程编辑器表单的视图之后，<br>必须在回发时捕获已更新的对象。<br>就像使用 <code>@Out</code> 将变量推送到视图中一样，<br>可以使用 <code>@In</code> 在回发时重新捕获它们。</p><p></p>
<pre><code>&lt;p&gt;当用户处理加载到表单中的课程信息时，
</code></pre><p>该课程实体耐心地在 conversation 作用域中等待。<br>因为应用程序使用无状态的服务接口，所以此时的课程实例<br>看作已经与持久化上下文 “分离”。提交该表单时，<br>最终到达 JSF 的更新模型值（Update Model Value）阶段。<br>此时，与表单中字段有关的课程对象将收到用户的更新。<br>当调用该操作方法时，必须重新使已更新的对象与持久化<br>上下文建立联系。通过使用 <code>save()</code><br>方法将该对象传递回服务层，就可以实现。</p><br>            <p>但是等等 —— 验证在哪里？您肯定不希望无效数据损坏您的数据库！<br>另一方面，您可能不希望验证标记打乱您的视图模板。<br>您甚至可能同意验证代码不属于视图层的说法。<br>幸运的是，Seam 负责完成 JSF 验证的琐碎工作！</p><br>            <p><a name="N1048F"><span class="smalltitle">借助 Seam 和 Hibernate 进行验证</span></a></p><br>            <p>如果您将整个表单包装到一个 <code>s:validateAll</code> 组件标记中，<br>Seam 允许您在 JSF 的流程验证（Process<br> Validation）阶段执行对数据模型<br>定义的验证。这种验证方法比以下方法更有吸引力：<br>在视图中到处设置 JSF 验证器标记，或者维护一个配置文件，<br>写满针对第三方验证框架的验证定义。取而代之，<br>可以使用 Hibernate Validator<br>注释向实体类属性指派验证标准，<br>如清单 13 所示。然后 Hibernate 在持久化对象时，对验证进行两次检查，为您提供<i>双重</i>保护。这个双重保障方法意味着<br>视图中不小心出现的 bug 没有任何机会危害您的数据质量。（请参阅 <a href="http://www.ibm.com/developerworks/cn/java/j-seam2/#resources" target="_blank" rel="noopener">参考资料</a> 了解关于 Hibernate<br>Validator 的更多内容。）</p><br>            <br><a name="listing13"><b>清单 13. 带有 Hibernate 验证注释的课程实体</b></a><br><table width="100%" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code-outline"><pre class="displaycode">                <br>@Entity<br>@Table(name = “course”)<br>public class Course implements Serializable {<br><br>    private long id;<br>    private String name;<br>    private CourseType type = CourseType.PUBLIC;<br>    private Address address;<br>    private String uri;<br>    private String phoneNumber;<br>    private String description;<br><br>    public Course() {}<br><br>    @Id<br>    @GeneratedValue(strategy = GenerationType.AUTO)<br>    @Column(name = “id”)<br>    @NotNull<br>    public long getId() {<br>        return this.id;<br>    }<br><br>    public void setId(long id) {<br>        this.id = id;<br>    }<br><br>    @Column(name = “name”)<br>    @NotNull<br>    @Length(min = 1, max = 50)<br>    public String getName() {<br>        return this.name;<br>    }<br><br>    public void setName(String name) {<br>        this.name = name;<br>    }<br><br>    @Column(name = “type”)<br>    @Enumerated(EnumType.STRING)<br>    @NotNull<br>    public CourseType getType() {<br>        return type;<br>    }<br><br>    public void setType(CourseType type) {<br>        this.type = type;<br>    }<br><br>    @Embedded<br>    public Address getAddress() {<br>        return address;<br>    }<br>    <br>    public void setAddress(Address address) {<br>        this.address = address;<br>    }<br>    <br>    @Column(name = “uri”)<br>    @Length(max = 255)<br>    @Pattern(regex = “^https?://.+$”, message = “validator.custom.url”)<br>    public String getUri() {<br>        return this.uri;<br>    }<br><br>    public void setUri(String uri) {<br>        this.uri = uri;<br>    }<br><br>    @Column(name = “phone”)<br>    @Length(min = 10, max = 10)<br>    @Pattern(regex = “^\d*$”, message = “validator.custom.digits”)<br>    public String getPhoneNumber() {<br>        return this.phoneNumber;<br>    }<br><br>    public void setPhoneNumber(String phoneNumber) {<br>        this.phoneNumber = phoneNumber;<br>    }<br><br>    @Column(name = “description”)<br>    public String getDescription() {<br>        return this.description;<br>    }<br><br>    public void setDescription(String description) {<br>        this.description = description;<br>    }<br><br>    // equals and hashCode not shown<br>}<br><br></pre></td></tr></tbody></table><br><br>            <p><a name="N104AD"><span class="smalltitle">只需少量步骤 …</span></a></p><br>            <p>课程对象仅在回发时注入，而回发是用户提交课程编辑器表单<br>触发的，不是由每个涉及<br><code>courseAction</code> 组件的请求触发的。<br>要想有条件地使用 <code>@In</code> 注释，必须在定义它时将<br>其 <code>required</code> 标志设置为 <i>false</i>。这样做<br>可以确保 Seam 在找不到要注入的课程对象时不会发出警报。</p><br>            <p>当提交课程编辑器表单时，就可以注入以前提取的课程对象。<br>要确保将该实例重新注入回同一属性，则向 <code>@In</code> 注释提供的名称必须等价于<br>                    <code>@Out</code> 注释所使用的名称。<br>作为添加这些内容的结果，<i>selectedCourse</i> 属性现在拥有三个注释。<br>（情况变得复杂起来！）</p><br>            <p>还必须向支持 bean 提供三个额外的操作方法，以处理<br>讲述到的新 CRUD 操作。新注释以及 <code>addCourse()</code>、<code>editCourse()</code> 和 <code>saveCourse()</code><br>操作方法如清单 14 所示：</p><br>            <br><a name="listing14"><b>清单 14. 用于创建、编辑和保存课程的其他操作</b></a><br><table width="100%" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code-outline"><pre class="displaycode">                <br>    // …<br><br>    @DataModelSelection<br>    @In(value=”course”, required=false)<br>    @Out(value=”course”, required=false)<br>    private Course selectedCourse;<br>    <br>    public String addCourse() {<br>        selectedCourse = new Course();<br>        selectedCourse.setAddress(new Address());<br>        return “/courseEditor.jspx”;<br>    }<br>    <br>    public String editCourse() {<br>        selectedCourse = courseManager.get(selectedCourse.getId());<br>        return “/courseEditor.jspx”;<br>    }<br>    <br>    public String saveCourse() {<br>        // remove course from cached collection<br>        // optionally, the collection could be nullified, forcing a refetch<br>        if (selectedCourse.getId() &gt; 0) {<br>            courses.remove(selectedCourse);<br>        }<br>        courseManager.save(selectedCourse);<br>        // add course to the cached collection<br>        // optionally, the collection could be nullified, forcing a refetch<br>        courses.add(selectedCourse);<br>        FacesMessages.instance().add(“#{course.name} has been saved.”);<br>        return “/courses.jspx”;<br>    }<br><br>    // …<br></pre></td></tr></tbody></table><br><p></p>
<pre><code>&lt;p&gt;课程编辑器页面负责创建和更新。Seam 之所以这么酷，是因为它能够暗中指挥通信，在这个例子中，
</code></pre><p>是通过在您浏览页面时将所选课程保存在上下文中实现的。<br>不需要使用 <code>HttpSession</code> 请求参数，<br>也不需要想方设法存储所选课程。而仅仅是提取想要公开的内容，<br>并注入期望接收的内容。</p><br>            <br><table width="100%" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><img src="http://www.ibm.com/i/v14/rules/blue_rule.gif" alt="" width="100%" height="1"><br><img alt="" src="http://www.ibm.com/i/c.gif" width="8" border="0" height="6"></td></tr></tbody></table><table class="no-print" align="right" cellpadding="0" cellspacing="0"><tbody><tr align="right"><td><img src="http://www.ibm.com/i/c.gif" alt="" width="100%" height="4"><br><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td valign="middle"><img src="http://www.ibm.com/i/v14/icons/u_bold.gif" alt="" width="16" border="0" height="16"><br></td><td valign="top" align="right"><a href="http://www.ibm.com/developerworks/cn/java/j-seam2/#main" class="fbox" target="_blank" rel="noopener"><b>回页首</b></a></td></tr></tbody></table></td></tr></tbody></table><br><br><p><a name="N104F2"><span class="atitle">编辑器模板</span></a></p><br>            <p>从编辑器页面（如清单<br>15 所示）观察表单组件。该页使用了以下两个 Seam 组件标记，使得开发视图的工作变得更加简单：</p><br>            <ul><li><br>                    <b><br>                        <code>s:decorate</code><br>                    </b> 结合 <code>afterInvalidField</code> facet 在每个输入组件之后插入 <code>s:message</code> 组件，<br>输入组件使您不必在页面中重复标记。</li><li><br>                    <b><br>                        <code>s:validateAll</code><br>                    </b> 指导 Seam 将 Hibernate Validator 注释结合到 JSF 验证过程，<br>以便在回发时验证表单中的每个字段。</li></ul><br>            <p>您不会在课程编辑器视图页面上发现任何本地 JSF 验证器，<br>因为 Seam 在利用 Hibernate Validator 时，完全不需使用本地验证器。<br>该页面还显示了 Seam 附带的<i>枚举转换器</i> 组件，以防您碰巧使<br>用 Java 5 枚举类型。</p><br>            <br><a name="listing15"><b>清单 15. 课程编辑器视图</b></a><br><table width="100%" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code-outline"><pre class="displaycode">                <br>&lt;h2&gt;&lt;h:outputText value=”#{course.id gt 0 ? ‘Edit’ : ‘Create’} Course” /&gt;&lt;/h2&gt;<br>&lt;h:form id=”course”&gt;<br>  &lt;s:validateAll&gt;<br>    &lt;f:facet name=”afterInvalidField”&gt;<br>      &lt;s:span styleClass=”error”&gt;<br>        &lt;s:message showDetail=”true” showSummary=”false”/&gt;<br>      &lt;/s:span&gt;<br>    &lt;/f:facet&gt;<br>    &lt;ul&gt;<br>      &lt;li&gt;<br>        &lt;h:outputLabel for=”name” value=”Course Name”/&gt;<br>        &lt;s:decorate&gt;<br>          &lt;h:inputText id=”name” value=”#{course.name}” required=”true”/&gt;<br>        &lt;/s:decorate&gt;<br>      &lt;/li&gt;<br>      &lt;li&gt;<br>        &lt;h:outputLabel for=”type” value=”Type”/&gt;<br>        &lt;s:decorate&gt;<br>           &lt;h:selectOneMenu id=”type” value=”#{course.type}”&gt;<br>             &lt;s:convertEnum /&gt;<br>             &lt;s:enumItem enumValue=”PUBLIC” label=”Public” /&gt;<br>             &lt;s:enumItem enumValue=”PRIVATE” label=”Private” /&gt;<br>             &lt;s:enumItem enumValue=”SEMI_PRIVATE” label=”Semi-Private” /&gt;<br>             &lt;s:enumItem enumValue=”RESORT” label=”Resort” /&gt;<br>             &lt;s:enumItem enumValue=”MILITARY” label=”Military” /&gt;<br>           &lt;/h:selectOneMenu&gt;<br>        &lt;/s:decorate&gt;<br>      &lt;/li&gt;<br>      &lt;li&gt;<br>        &lt;h:outputLabel for=”uri” value=”Website” /&gt;<br>        &lt;s:decorate&gt;<br>          &lt;h:inputText id=”uri” value=”#{course.uri}”/&gt;<br>        &lt;/s:decorate&gt;<br>      &lt;/li&gt;<br>      &lt;li&gt;<br>        &lt;h:outputLabel for=”phone” value=”Phone Number” /&gt;<br>        &lt;s:decorate&gt;<br>          &lt;h:inputText id=”phone” value=”#{course.phoneNumber}”/&gt;<br>        &lt;/s:decorate&gt;<br>      &lt;/li&gt;<br>      &lt;li&gt;<br>        &lt;h:outputLabel for=”city” value=”City” /&gt;<br>        &lt;s:decorate&gt;<br>          &lt;h:inputText id=”city” value=”#{course.address.city}”/&gt;<br>        &lt;/s:decorate&gt;<br>      &lt;/li&gt;<br>      &lt;li&gt;<br>        &lt;h:outputLabel for=”state” value=”State” /&gt;<br>        &lt;s:decorate&gt;<br>          &lt;h:selectOneMenu id=”state” value=”#{course.address.state}” required=”true”&gt;<br>            &lt;s:selectItems var=”state” value=”#{states}” label=”#{state}” /&gt;<br>          &lt;/h:selectOneMenu&gt;<br>        &lt;/s:decorate&gt;<br>      &lt;/li&gt;<br>      &lt;li&gt;<br>        &lt;h:outputLabel for=”zip” value=”ZIP Code” /&gt;<br>        &lt;s:decorate&gt;<br>          &lt;h:inputText id=”zip” value=”#{course.address.city}”/&gt;<br>        &lt;/s:decorate&gt;<br>      &lt;/li&gt;<br>      &lt;li&gt;<br>        &lt;h:outputLabel for=”description” value=”Description” /&gt;<br>        &lt;s:decorate&gt;<br>          &lt;h:inputTextarea id=”description” value=”#{course.description}”/&gt;<br>        &lt;/s:decorate&gt;<br>      &lt;/li&gt;<br>    &lt;ul&gt;<br>  &lt;/s:validateAll&gt;<br>  &lt;p class=”commands”&gt;<br>    &lt;h:commandButton id=”save” action=”#{courseAction.saveCourse}” value=”Save”/&gt;<br>    &lt;s:button id=”cancel” view=”/courses.jspx” value=”Cancel”/&gt;<br>  &lt;/p&gt;<br>&lt;/h:form&gt;<br></pre></td></tr></tbody></table><br><br>            <br><table width="100%" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><img src="http://www.ibm.com/i/v14/rules/blue_rule.gif" alt="" width="100%" height="1"><br><img alt="" src="http://www.ibm.com/i/c.gif" width="8" border="0" height="6"></td></tr></tbody></table><table class="no-print" align="right" cellpadding="0" cellspacing="0"><tbody><tr align="right"><td><img src="http://www.ibm.com/i/c.gif" alt="" width="100%" height="4"><br><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td valign="middle"><img src="http://www.ibm.com/i/v14/icons/u_bold.gif" alt="" width="16" border="0" height="16"><br></td><td valign="top" align="right"><a href="http://www.ibm.com/developerworks/cn/java/j-seam2/#main" class="fbox" target="_blank" rel="noopener"><b>回页首</b></a></td></tr></tbody></table></td></tr></tbody></table><br><br><p><a name="N1052A"><span class="atitle">添加删除功能</span></a></p><br>            <p>回顾代码片段，可以发现到目前为止重点内容大多涉及<br>消除代码、选择，而不是通过注释描述功能，并由框架负责处理细节。<br>这种简单性允许您集中精力处理更复杂的问题，并添加深受大家喜欢的<br>奇特 <i>Ajaxian</i> 效果。您可能尚未认识到只需再做少量工作，就<br>可以实现所有 CRUD 操作 —— 实际上即将到达最后阶段！</p><br>            <p>在应用程序中实现删除功能是一项简单的事情。<br>只需向每行添加另一个 <code>h:commandLink</code>，该命令链接<br>能激活支持 bean 的删除方法（<code>deleteCourse()</code>）。我们已经<br>实现了公开所选课程的工作，仅仅需要将绑定到课程属性的课程对象传递给<br><code>CourseManager</code> 以终止该课程，如<br>清单 16 中所示：</p><br>            <br><a name="listing16"><b>清单 16. 向 deleteCourse 添加命令链接</b></a><br><table width="100%" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code-outline"><pre class="displaycode">                <br>&lt;h:dataTable id=”courses” var=”_course” value=”#{courses}”<br>  rendered=”#{courses.rowCount gt 0}”&gt;<br>  &lt;h:column&gt;<br>    &lt;f:facet name=”header”&gt;Course Name&lt;/f:facet&gt;<br>    &lt;h:commandLink id=”select”<br>        action=”#{courseAction.selectCourse}” value=”#{_course.name}” /&gt;<br>  &lt;/h:column&gt;<br>  &lt;h:column&gt;<br>    &lt;f:facet name=”header”&gt;Actions&lt;/f:facet&gt;<br>    &lt;h:commandLink id=”delete” action=”#{courseAction.deleteCourse}” value=”Delete” /&gt;<br>  &lt;/h:column&gt;<br>  &lt;!– additional properties –&gt;<br>&lt;/h:dataTable&gt;<br></pre></td></tr></tbody></table><br><br>            <p>在 <code>deleteCourse()</code> 方法中，如清单<br>17中所示，利用 Seam 的 <code>FacesMessages</code> 组件警告用户正<br>在发生的操作。该消息是以典型的途径在视图中使用<br><code>h:messages</code> JSF 组件显示的。但是首先请注意，<br>创建消息是多么简单！您可以彻底抛弃以前令人头疼的<br>JSF 工具类；Seam 可靠地消除了 JSF 以前的阴影。</p><br>            <br><a name="listing17"><b>清单 17. 向 deleteCourse 添加操作方法</b></a><br><table width="100%" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code-outline"><pre class="displaycode">                <br>    // …<br><br>    public String deleteCourse() {<br>        courseManager.remove(selectedCourse.getId());<br>        courses.remove(selectedCourse);<br>        FacesMessages.instance().add(selectedCourse.getName() + “ has been removed.”);<br>        // clear selection so that it won’t be shown in the detail pane<br>        selectedCourse = null;<br>        return “/courses.jspx”;<br>    }<br><br>    // …</pre></td></tr></tbody></table><br><br>            <br><table width="100%" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><img src="http://www.ibm.com/i/v14/rules/blue_rule.gif" alt="" width="100%" height="1"><br><img alt="" src="http://www.ibm.com/i/c.gif" width="8" border="0" height="6"></td></tr></tbody></table><table class="no-print" align="right" cellpadding="0" cellspacing="0"><tbody><tr align="right"><td><img src="http://www.ibm.com/i/c.gif" alt="" width="100%" height="4"><br><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td valign="middle"><img src="http://www.ibm.com/i/v14/icons/u_bold.gif" alt="" width="16" border="0" height="16"><br></td><td valign="top" align="right"><a href="http://www.ibm.com/developerworks/cn/java/j-seam2/#main" class="fbox" target="_blank" rel="noopener"><b>回页首</b></a></td></tr></tbody></table></td></tr></tbody></table><br><br><p><a name="N10568"><span class="atitle">完整的课程列表</span></a></p><br>            <p>处理完所有 CRUD 操作，就即将完工了！剩下的惟一的一个步骤<br>是将整个课程列表组装到一起，如清单 18 所示：</p><br>            <br><a name="listing18"><b>清单 18. 完整的课程列表视图</b></a><br><table width="100%" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code-outline"><pre class="displaycode">                <br>&lt;h2&gt;Courses&lt;/h2&gt;<br><br>&lt;h:messages id=”messages” globalOnly=”true” /&gt;<br><br>&lt;h:panelGroup rendered=”#{courses.rowCount eq 0}”&gt;<br>  No courses found.<br>&lt;/h:panelGroup&gt;<br><br>&lt;h:dataTable id=”courses” var=”_course” value=”#{courses}”<br>  rendered=”#{courses.rowCount gt 0}”&gt;<br>  &lt;h:column&gt;<br>    &lt;f:facet name=”header”&gt;Course Name&lt;/f:facet&gt;<br>    &lt;h:commandLink id=”select”<br>        action=”#{courseAction.selectCourse}” value=”#{_course.name}” /&gt;<br>  &lt;/h:column&gt;<br>  &lt;h:column&gt;<br>    &lt;f:facet name=”header”&gt;Location&lt;/f:facet&gt;<br>    &lt;h:outputText value=”#{course.address.city}, #{course.address.state}” /&gt;<br>  &lt;/h:column&gt;<br>  &lt;h:column&gt;<br>    &lt;f:facet name=”header”&gt;Phone Number&lt;/f:facet&gt;<br>    &lt;h:outputText value=”#{course.phoneNumber} /&gt;<br>  &lt;/h:column&gt;<br>  &lt;h:column&gt;<br>    &lt;f:facet name=”header”&gt;Actions&lt;/f:facet&gt;<br>    &lt;h:panelGroup&gt;<br>      &lt;h:commandLink id=”edit” action=”#{courseAction.editCourse}” value=”Edit” /&gt;<br>      &lt;h:commandLink id=”delete” action=”#{courseAction.deleteCourse}” value=”Delete” /&gt;<br>    &lt;/h:panelGroup&gt;<br>  &lt;/h:column&gt;<br>&lt;/h:dataTable&gt;<br><br>&lt;h:commandButton id=”add” action=”#{courseAction.addCourse}” value=”Add Course” /&gt;<br><br>&lt;h:panelGroup rendered=”#{course.id gt 0}”&gt;<br>  &lt;h3&gt;Course Detail&lt;/h3&gt;<br>  &lt;table class=”detail”&gt;<br>    &lt;col width=”20%” /&gt;<br>    &lt;col width=”80%” /&gt;<br>    &lt;tr&gt;<br>      &lt;th&gt;Course Name&lt;/th&gt;<br>      &lt;td&gt;#{course.name} &lt;span class=”notation”&gt;(#{course.type})&lt;/span&gt;&lt;/td&gt;<br>    &lt;/tr&gt;<br>    &lt;tr&gt;<br>      &lt;th&gt;Website&lt;/th&gt;<br>      &lt;td&gt;&lt;h:outputLink value=”#{course.uri}”<br>        rendered=”#{not empty course.uri}”&gt;#{course.uri}&lt;/h:outputLink&gt;&lt;/td&gt;<br>    &lt;/tr&gt;<br>    &lt;tr&gt;<br>      &lt;th&gt;Phone&lt;/th&gt;<br>      &lt;td&gt;#{course.phoneNumber}&lt;/td&gt;<br>    &lt;/tr&gt;<br>    &lt;tr&gt;<br>      &lt;th&gt;State&lt;/th&gt;<br>      &lt;td&gt;#{course.address.state}&lt;/td&gt;<br>    &lt;/tr&gt;<br>    &lt;tr&gt;<br>      &lt;th&gt;City&lt;/th&gt;<br>      &lt;td&gt;#{course.address.city}&lt;/td&gt;<br>    &lt;/tr&gt;<br>    &lt;tr&gt;<br>      &lt;th&gt;ZIP Code&lt;/th&gt;<br>      &lt;td&gt;#{course.address.postalCode}&lt;/td&gt;<br>    &lt;/tr&gt;<br>  &lt;/table&gt;<br>  &lt;h:panelGroup rendered=”#{not empty course.description}”&gt;<br>  &lt;p&gt;&lt;q&gt;…#{course.description}&lt;/q&gt;&lt;/p&gt;<br>  &lt;/h:panelGroup&gt;<br>&lt;/h:panelGroup&gt;<br></pre></td></tr></tbody></table><br><br>            <p>恭喜！您完成了第一个基于 Seam 的 CRUD 应用程序。</p><br>            <br><table width="100%" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><img src="http://www.ibm.com/i/v14/rules/blue_rule.gif" alt="" width="100%" height="1"><br><img alt="" src="http://www.ibm.com/i/c.gif" width="8" border="0" height="6"></td></tr></tbody></table><table class="no-print" align="right" cellpadding="0" cellspacing="0"><tbody><tr align="right"><td><img src="http://www.ibm.com/i/c.gif" alt="" width="100%" height="4"><br><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td valign="middle"><img src="http://www.ibm.com/i/v14/icons/u_bold.gif" alt="" width="16" border="0" height="16"><br></td><td valign="top" align="right"><a href="http://www.ibm.com/developerworks/cn/java/j-seam2/#main" class="fbox" target="_blank" rel="noopener"><b>回页首</b></a></td></tr></tbody></table></td></tr></tbody></table><br><br><p><a name="N1057E"><span class="atitle">结束语</span></a></p><br>            <p>在 <a href="http://www.ibm.com/developerworks/cn/java/j-seam/" target="_blank" rel="noopener">无缝 JSF</a> 系列第二篇文章中，您亲自发现了 Seam 的<br>Java 5 注释如何简化代码，conversation 作用域如何自动在一系列请求期间管理状态，<br>以及如何同时使用 Seam 和 Hibernate Validator 对输入数据执行数据模<br>型验证。</p><br>            <p>实际上可以使用 seam-gen 自动完成大多数 CRUD 工作（请参见 <a href="http://www.ibm.com/developerworks/cn/java/j-seam2/#resources" target="_blank" rel="noopener">参考资料</a>），<br>seam-gen 是 Ruby-on-Rails 样式的 Seam 应用程序生成器。但是我希望您从本文的练习<br>中了解到 Seam 不仅仅是另一个 Web 框架。采用 Seam 并不强制您抛弃 JSF 经<br>验。相反，Seam 是对 JSF 非常强大的扩展，实际上它增强了 JSF 的生命周期。Seam 和 JSF 结合起来可以顺利地和任何无状态的服务层或 EJB3 模型进行集成。</p><br>            <p>既然已经了解 Seam 减轻 JSF 开发的一些方式，<br>您可能想知道它对 <a href="http://www.ibm.com/developerworks/cn/java/j-seam1/index.html" target="_blank" rel="noopener">第 1 部分</a> 中<br>讨论的更高级 Web 2.0 技术的支持程度。在本系列的最后<br>一个部分中，将讲述如何使用 Ajax remoting 通过在课程目录<br>和 Google Maps 之间创建 mashup，<br>进一步开发 Open 18 应用程序，<br>在这个过程中，您将了解 Seam 的 Java 5 注释和捆绑的 JavaScript<br>库如何指导浏览器和服务器端组件之间的通信。</p><br>            <p>再见，同时祝您玩高尔夫愉快！</p><br>        <br><br><table width="100%" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><img src="http://www.ibm.com/i/v14/rules/blue_rule.gif" alt="" width="100%" height="1"><br><img alt="" src="http://www.ibm.com/i/c.gif" width="8" border="0" height="6"></td></tr></tbody></table><table class="no-print" align="right" cellpadding="0" cellspacing="0"><tbody><tr align="right"><td><img src="http://www.ibm.com/i/c.gif" alt="" width="100%" height="4"><br><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td valign="middle"><img src="http://www.ibm.com/i/v14/icons/u_bold.gif" alt="" width="16" border="0" height="16"><br></td><td valign="top" align="right"><a href="http://www.ibm.com/developerworks/cn/java/j-seam2/#main" class="fbox" target="_blank" rel="noopener"><b>回页首</b></a></td></tr></tbody></table></td></tr></tbody></table><br><br><p><span class="atitle"><a name="download">下载</a></span></p><table class="data-table-1" width="100%" border="0" cellpadding="0" cellspacing="0"><tbody><tr><th scope="col">描述</th><th scope="col">名字</th><th scope="col">大小</th><th scope="col">下载方法</th></tr><tr><th class="tb-row" scope="row">open 18 样例应用程序 —— 第 1 阶段<sup>1</sup></th><td nowrap="nowrap">j-seam2.zip</td><td nowrap="nowrap">248KB</td><td nowrap="nowrap"><a class="fbox" href="http://download.boulder.ibm.com/ibmdl/pub/software/dw/java/j-seam2.zip" target="_blank" rel="noopener"><b>HTTP</b></a></td></tr></tbody></table><table border="0" cellpadding="0" cellspacing="0"><tbody><tr valign="top"><td colspan="5"><img alt="" src="http://www.ibm.com/i/c.gif" width="12" border="0" height="12"></td></tr><tr><td><img alt="" src="http://www.ibm.com/i/v14/icons/fw.gif" width="16" height="16"></td><td><a class="fbox" href="http://www.ibm.com/developerworks/cn/whichmethod.html" target="_blank" rel="noopener">关于下载方法的信息</a></td><td><img alt="" src="http://www.ibm.com/i/c.gif" width="50" height="1"></td></tr></tbody></table><p><b>注意：</b></p><ol><li>样例应用程序被组织成 Maven 2 项目。在执行构建时，会根据需要取出所有依赖项。该应用程序使用若干 Appfuse 项目库来实现服务层和 DAO 层。</li></ol><br><br><p><a name="resources"><span class="atitle">参考资料 </span></a></p><b>学习</b><br><ul><li>您可以参阅本文在 developerWorks 全球站点上的 <a href="http://www.ibm.com/developerworks/java/library/j-seam2/?S_TACT=105AGX52&amp;S_CMP=cn-a-j" target="_blank">英文原文</a> 。<br><br></li><li>“<a href="http://www.ibm.com/developerworks/cn/java/j-seam1/index.html" target="_blank" rel="noopener">Seam - 无缝集成 JSF，第 1 部分：为 JSF 量身定做的应用程序框架</a>”（Dan Allen，developerWorks，2007 年 4 月）：概述了 Seam 对 JSF 生命周期的增强，包括第 2 部分中使用的内容。<br><br></li><li>“<a href="http://www.ibm.com/developerworks/edu/os-dw-os-ag-jsf5.html?S_TACT=105AGX52&amp;S_CMP=cn-a-j" target="_blank" rel="noopener">Build Apache Geronimo applications using JavaServer Faces: Integrating your JSF application with Spring</a>”（Chris Herborth，developerWorks，2006 年 9 月）：集成 Spring 和 JSF 的入门教程。这是关于开发 JSF 应用程序的系列文章（分为 5 个部分）的最后一部分。<br><br></li><li>“<a href="http://www.ibm.com/developerworks/cn/java/j-hibval.html" target="_blank" rel="noopener">Hibernate 能够满足我们的验证需求</a>”（Ted Bergeron，developerWorks，2006 年 9 月）：了解如何使用 Hibernate 的注释驱动的验证器来构建和维护验证逻辑。<br><br></li><li>“<a href="http://weblogs.java.net/blog/bleonard/archive/2006/11/a_conversation.%20html" target="_blank" rel="noopener">A Conversation with Seam</a>”（Brian Leonard的blog，2006 年 11 月）：演示了 Seam 如何隔离并发对话。<br><br></li><li>“<a href="http://docs.jboss.com/seam/latest/reference/en/html/gettingstarted.html" target="_blank" rel="noopener">Getting started with Seam, using seam-gen</a>”（Seam 教程，JBoss.org）：了解如何使用 seam-gen 创建基本的 CRUD 应用程序。（但是这样做有什么好处？）<br><br></li><li><br>                <a href="http://www.infoq.com/articles/jboss-seam" target="_blank" rel="noopener">InfoQ</a>：了解关于 Seam 的更多采访和文章。<br><br></li><li><br>                <a href="http://safari.oreilly.com/013241273X/ch16" target="_blank" rel="noopener"><br>                    <i>JBoss Seam: Simplicity and Power Beyond Java EE</i><br>                </a>（Michael Juntao Yuan and Thomas Heute；Prentice Hall，2007 年 4 月）：刚刚出版，这是第一本以图书的篇幅介绍使用 Seam 进行 JSF 开发。<br><br></li><li><br>                <a href="http://docs.jboss.com/seam/latest/reference/en/html/index.html" target="_blank" rel="noopener">The Seam Reference Documentation</a>：绝对是关于 Seam 的经典文章。<br><br></li><li><br>                <a href="http://www.ibm.com/developerworks/cn/java/" target="_blank" rel="noopener">developerWorks Java 技术专区</a>：提供了数百篇关于 Java 编程方方面面的文章。</li></ul><br><b>获得产品和技术</b><br><ul><li><br>                <a href="http://labs.jboss.com/portal/jbossseam/download/index.html" target="_blank" rel="noopener">JBoss Seam</a>：下载完整的发行版，包括附带的例子应用程序。<br><br></li><li><br>                <a href="http://www.hibernate.org/412.html" target="_blank" rel="noopener">Hibernate</a>：初步了解 Hibernate Validator。<br><br></li><li><br>                <a href="http://geronimo.apache.org/downloads.html" target="_blank" rel="noopener">Apache Geronimo</a>：下载 Java EE 5 版本，然后利用 Seam 的 EJB3 集成功能。<br><br></li><li><br>                <a href="http://maven.apache.org/" target="_blank" rel="noopener">Maven 2</a>：在源码样例中使用的软件项目管理和综合工具。Maven 会自动在构建过程中下载依赖项。<br><br></li><li><br>                <a href="https://facelets.dev.java.net/" target="_blank" rel="noopener">Facelets</a>：针对 Seam 应用程序的首选 JSF 视图处理器。<br><br></li><li><br>                <a href="http://www.appfuse.org/" target="_blank" rel="noopener">Appfuse</a>：实际上向您提供了非常全面的基于 Maven 2 的项目框架，可用于根据其构建自己的应用程序。<br><br></li></ul><br><b>讨论</b><br><ul><li><br>                <a href="http://labs.jboss.com/portal/jbossseam/blog" target="_blank" rel="noopener">Seam blog</a>：了解其他用户对于 Seam 的看法，然后在 <a href="http://www.jboss.com/index.html?module=bb&amp;op=viewforum&amp;f=231" target="_blank" rel="noopener"><br>Seam 社区论坛</a> 中提交反馈。<br><br></li></ul><br><br><p><a name="author"><span class="atitle">关于作者</span></a></p><table width="100%" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td colspan="3"><img alt="" src="http://www.ibm.com/i/c.gif" width="100%" height="5"></td></tr><tr valign="top" align="left"><td><p><img alt="Dan Allen" src="http://www.ibm.com/developerworks/i/p-dallen.jpg" valign="top" align="left"></p></td><td><img alt="" src="http://www.ibm.com/i/c.gif" width="4" height="5"></td><td width="100%"><p>Dan Allen 目前是 CodeRyte 的一名高级 Java 工程师。他还是一名热情的开放源码拥护者，每当他看到企鹅时就会有一点疯狂。<br>从 Cornell 大学毕业并获得材料科学与工程学位，Dan 对 Linux 和开放源码软件非常着迷。从那以后，他就沉浸在 Web 应用程序领域，最近几年则专攻 Java 相关的技术，包括<br>Spring、Hibernate、Maven 2 和丰富的 JSF 堆栈。您可以在 <a href="http://www.mojavelinux.com/" target="_blank" rel="noopener">http://www.mojavelinux.com</a> 订阅 Dan 的 blog，以跟踪他的开发经验。</p></td></tr></tbody></table><br>转自：<a href="http://www.ibm.com/developerworks/cn/java/j-seam2/" target="_blank" rel="noopener">http://www.ibm.com/developerworks/cn/java/j-seam2/</a><p></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/blog/tags/JSF/" rel="tag"># JSF</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/blog/cjcujzitd00g9xwrqpke8anwx/" rel="next" title="Seam - 无缝集成 JSF，第 1 部分: 为 JSF 量身定做的应用程序框架">
                <i class="fa fa-chevron-left"></i> Seam - 无缝集成 JSF，第 1 部分: 为 JSF 量身定做的应用程序框架
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/blog/cjcujzito00gjxwrq38f0jvxq/" rel="prev" title="Seam - 无缝集成 JSF，第 3 部分: 用于 JSF 的 Ajax">
                Seam - 无缝集成 JSF，第 3 部分: 用于 JSF 的 Ajax <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Vanessa</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/blog/archives/">
              
                  <span class="site-state-item-count">874</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">224</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Vanessa</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/blog/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/blog/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/blog/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/blog/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/blog/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/blog/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
