<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/blog/lib/fancybox/source/jquery.fancybox.css" rel="stylesheet" type="text/css" />







<link href="/blog/lib/font-awesome/css/font-awesome.min.css" rel="stylesheet" type="text/css" />

<link href="/blog/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/blog/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Java," />










<meta name="description" content="GEF 概述      GEF 假定您拥有一个希望以图形方式显示和编辑的模型。为了做到这一点，GEF 提供了可在 Eclipse 工作台中任何地方使用的查看器（类型为        EditPartViewer ）。象 JFace 查看器一样，GEF 查看器是 SWT 控件上的适配器。但是它们的类似之处仅此而已。GEF 查看器基于模型-视图-控制器（model-view-controller，MV">
<meta name="keywords" content="Java">
<meta property="og:type" content="article">
<meta property="og:title" content="使用图形编辑框架创建基于 Eclipse 的应用程序">
<meta property="og:url" content="https://vanessa.js.org/blog/cjcuko5bx010s4urqhczz13ns/index.html">
<meta property="og:site_name" content="Vanessa">
<meta property="og:description" content="GEF 概述      GEF 假定您拥有一个希望以图形方式显示和编辑的模型。为了做到这一点，GEF 提供了可在 Eclipse 工作台中任何地方使用的查看器（类型为        EditPartViewer ）。象 JFace 查看器一样，GEF 查看器是 SWT 控件上的适配器。但是它们的类似之处仅此而已。GEF 查看器基于模型-视图-控制器（model-view-controller，MV">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://www.ibm.com/developerworks/cn/linux/opensource/os-gef/fig1.gif">
<meta property="og:image" content="http://www.ibm.com/i/v14/rules/blue_rule.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/v14/icons/u_bold.gif">
<meta property="og:image" content="http://www.ibm.com/developerworks/cn/linux/opensource/os-gef/fig2.gif">
<meta property="og:image" content="http://www.ibm.com/developerworks/cn/linux/opensource/os-gef/fig3.gif">
<meta property="og:image" content="http://www.ibm.com/i/v14/rules/blue_rule.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/v14/icons/u_bold.gif">
<meta property="og:image" content="http://www.ibm.com/i/v14/rules/blue_rule.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/v14/icons/u_bold.gif">
<meta property="og:image" content="http://www.ibm.com/developerworks/cn/linux/opensource/os-gef/fig4.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/v14/rules/blue_rule.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/v14/icons/u_bold.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/v14/rules/blue_rule.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/v14/icons/u_bold.gif">
<meta property="og:image" content="http://www.ibm.com/i/v14/rules/blue_rule.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/v14/icons/u_bold.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:image" content="http://www.ibm.com/i/c.gif">
<meta property="og:updated_time" content="2018-01-20T07:42:15.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="使用图形编辑框架创建基于 Eclipse 的应用程序">
<meta name="twitter:description" content="GEF 概述      GEF 假定您拥有一个希望以图形方式显示和编辑的模型。为了做到这一点，GEF 提供了可在 Eclipse 工作台中任何地方使用的查看器（类型为        EditPartViewer ）。象 JFace 查看器一样，GEF 查看器是 SWT 控件上的适配器。但是它们的类似之处仅此而已。GEF 查看器基于模型-视图-控制器（model-view-controller，MV">
<meta name="twitter:image" content="http://www.ibm.com/developerworks/cn/linux/opensource/os-gef/fig1.gif">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://vanessa.js.org/blog/cjcuko5bx010s4urqhczz13ns/"/>





  <title>使用图形编辑框架创建基于 Eclipse 的应用程序 | Vanessa</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/blog/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Vanessa</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/blog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/blog/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://vanessa.js.org/blog/blog/cjcuko5bx010s4urqhczz13ns/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Vanessa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vanessa">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">使用图形编辑框架创建基于 Eclipse 的应用程序</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2008-07-22T15:14:00+08:00">
                2008-07-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p></p><p><a name="N10048"><span class="atitle">GEF 概述</span></a></p><br>      <p>GEF 假定您拥有一个希望以图形方式显示和编辑的模型。为了做到这一点，GEF 提供了可在 Eclipse 工作台中任何地方使用的查看器（类型为<br>        <code>EditPartViewer</code> ）。象 JFace 查看器一样，GEF 查看器是 SWT 控件上的适配器。但是它们的类似之处仅此而已。GEF 查看器基于模型-视图-控制器（model-view-controller，MVC）体系结构。<br>      </p><br>      <p><br>        <i>控制器</i>作为视图和模型之间的桥梁（请参阅图 1）。每个控制器（即本文所谓的<br>        <i>EditPart</i>）负责将模型映射到它的视图，也负责对模型进行更改。EditPart 还观察模型并更新视图，以反映模型状态中的变化。EditPart 是一种对象，用户将与这种对象进行交互。稍后将更详细地介绍 EditPart。<br>      </p><br>      <p><br>        <a name="figure1"><br>          <b>图 1. 模型-视图-控制器</b><br>        </a><br>        <br><br>        <img alt="模型-视图-控制器" src="http://www.ibm.com/developerworks/cn/linux/opensource/os-gef/fig1.gif" height="165" width="215"><br>      </p><br>      <p>GEF 提供了两种查看器类型：图形的和基于树的。每种查看器都主管一种不同类型的<br>        <i>视图</i>。图形查看器使用了在 SWT<br>        <i>画布（Canvas）</i>上绘制的<br>        <i>图形（figure）</i>。图形是在 Draw2D 插件中定义的，该插件是 GEF 的一部分。TreeViewer 将 SWT 树和 TreeItem 用于其视图。<br>      </p><br>      <br><table border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td><img src="http://www.ibm.com/i/v14/rules/blue_rule.gif" alt="" height="1" width="100%"><br><img alt="" src="http://www.ibm.com/i/c.gif" border="0" height="6" width="8"></td></tr></tbody></table><table class="no-print" align="right" cellpadding="0" cellspacing="0"><tbody><tr align="right"><td><img src="http://www.ibm.com/i/c.gif" alt="" height="4" width="100%"><br><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td valign="middle"><img src="http://www.ibm.com/i/v14/icons/u_bold.gif" alt="" border="0" height="16" width="16"><br></td><td align="right" valign="top"><a href="http://www.ibm.com/developerworks/cn/linux/opensource/os-gef/index.html#main" class="fbox" target="_blank" rel="noopener"><b>回页首</b></a></td></tr></tbody></table></td></tr></tbody></table><br><br><p><a name="N1007C"><span class="atitle">第 1 步. 选定自己的模型</span></a></p><br>      <p>GEF 对于模型一无所知。任何模型类型都可工作，只要它符合下面描述的特性。</p><br>      <p><a name="N10085"><span class="smalltitle">模型中有什么？</span></a></p><br>      <p>所有东西都在模型中。模型是唯一会被持久存储和恢复的东西。您的应用程序应当将所有重要数据都存储在模型中。在编辑、撤销和重做的过程中，模型是唯一保持不变的。随着时间推移，将对图形和 EditPart 进行垃圾收集处理并重新创建。</p><br>      <p>当用户与 EditPart 交互时，EditPart 并不直接操作模型。而是创建一个封装了更改的<br>        <i>命令（Command）</i>。命令可用来验证用户的交互，并且提供撤销和重做支持。<br>      </p><br>      <p>严格地说，命令概念上也是模型一部分。它们<br>        <i>本身</i>并不是模型，而是一些方法，模型是由这些方法编辑的。命令用于执行用户的所有可撤销的更改。理论上，命令应当只了解模型。它们应当避免引用 EditPart 或图形。类似地，如果可能，命令应当避免调用用户界面（例如弹出式对话框）。<br>      </p><br>      <p><a name="N1009A"><span class="smalltitle">两个模型的故事</span></a></p><br>      <p>一个简单的 GEF 应用程序就是用于绘制图的编辑器。（这里<br>        <i>图</i>只意味着图片，而不是类图等）图可以被建模成某些形状。一个形状可能具有位置、颜色等特性，并且可能是多个形状构成的一组结构。这里没有什么可惊讶的，并且前述需求也易于维护（请参阅图 2）。<br>      </p><br>      <p><br>        <a name="figure2"><br>          <b>图 2. 一个简单的模型</b><br>        </a><br>        <br><br>        <img alt="一个简单的模型" src="http://www.ibm.com/developerworks/cn/linux/opensource/os-gef/fig2.gif" height="179" width="334"><br>      </p><br>      <p>另一种常见的 GEF 应用程序是 UML 编辑器，例如类图编辑器。图中的一段重要信息就是 (x, y) 位置，类就出现在该位置上。根据前一节的介绍，您可能会以为模型必须将一个<br>        <i>类</i>描述成具有<br>        <i>x</i>和<br>        <i>y</i>特<br>性。大多数开发人员都不希望由于无意义的属性而“污染”其模型。在这类应用程序中，术语“业务”模型可用于指代基本模型，重要语义的详细信息存储在基本模<br>型中。而特定于图的信息存储在“视图”模型（它指的是业务模型中某样东西的“视图”；在一个图中可多次查看某个对象）中。有时候这种划分甚至会反映在工作<br>空间中，其中不同的资源可能被分别用来持久存储图和业务模型。甚至可能有多个图对应于同一个业务模型（请参阅图 3）。 </p><br>      <p><br>        <a name="figure3"><br>          <b>图 3. 划分成业务模型和视图模型的模型</b><br>        </a><br>        <br><br>        <img alt="划分成业务模型和视图模型的模型" src="http://www.ibm.com/developerworks/cn/linux/opensource/os-gef/fig3.gif" height="255" width="552"><br>      </p><br>      <p>不管您的模型划分成了两个部分，还是划分成了多个资源，对于 GEF 而言这都是无关紧要的。术语模型用于指代整个应用程序模型。屏幕上的一个对象可能对应于模型中的多个对象。GEF 旨在允许开发人员方便地处理这类映射。</p><br>      <p><a name="N100D9"><span class="smalltitle">通知策略</span></a></p><br>      <p>对视图进行更新几乎总是由来自模型的通知而导致的。您的模型必须提供某种通知机制，该机制必须映射到您应用程序中相应的更新。而只读模型或不能进行通知的模型（例如文件系统或远程连接）可能是例外。</p><br>      <p>通<br>知策略通常是分布式的（每对象）或集中式的（每域）。域通知器了解到对模型中任何对象的每次更改，然后将这些更改向域侦听器广播。如果您的应用程序使用了<br>这种通知模型，您可能要为每个查看器添加一个域侦听器。当该侦听器接收到更改时，它将查找受影响的<br>EditPart，然后适当地重新分派该更改。如果您的应用程序使用了分布式通知，那么每个 EditPart<br>通常都将把自己的侦听器添加到任何一个影响它的模型对象。</p><br>      <br><table border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td><img src="http://www.ibm.com/i/v14/rules/blue_rule.gif" alt="" height="1" width="100%"><br><img alt="" src="http://www.ibm.com/i/c.gif" border="0" height="6" width="8"></td></tr></tbody></table><table class="no-print" align="right" cellpadding="0" cellspacing="0"><tbody><tr align="right"><td><img src="http://www.ibm.com/i/c.gif" alt="" height="4" width="100%"><br><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td valign="middle"><img src="http://www.ibm.com/i/v14/icons/u_bold.gif" alt="" border="0" height="16" width="16"><br></td><td align="right" valign="top"><a href="http://www.ibm.com/developerworks/cn/linux/opensource/os-gef/index.html#main" class="fbox" target="_blank" rel="noopener"><b>回页首</b></a></td></tr></tbody></table></td></tr></tbody></table><br><br><p><a name="N100E5"><span class="atitle">第 2 步. 定义视图</span></a></p><br>      <p>下<br>一步是决定将如何使用来自 Draw2D 插件的图形显示您的模型。某些图形可直接用来显示模型的某个对象。例如，Label 图形可用来显示<br>Image 和<br>String。有时候，通过组合多个图形、布局管理器和／或边框可以获得期望的结果。最后，您可能要编写自己的图形实现，该实现以特定于您应用程序的方式<br>绘图。</p><br>      <p>有关组合或实现图形和布局的更多信息可在 Draw2D 开发人员指南中找到，该指南包含在 GEF SDK 中。</p><br>      <p>在和 GEF 一起使用 Draw2D 时，通过遵循下列方针，可以使您的项目更便于管理，并且可以更灵活地更改需求：</p><br>      <ul><li><br>          <b>不要从头做起</b>。<br>您可以组合所提供的布局管理器以呈现大多数东西。请考虑使用工具栏布局（在垂直或水平方向上）和边框布局的组合来组合多个图形。只有在万不得已时才编写自<br>己的布局管理器。作为参考，请查看 GEF 中提供的调色板。该调色板是使用 Draw2D 中的许多标准图形和布局呈现的。 <br><br>          <br><br>        </li><li><br>          <b>保持 EditPart 和图形之间“彻底”的分离</b>。<br>如果您的 EditPart 使用了几个图形、布局和／或边框的复合结构，那么请尽量对 EditPart 隐藏详细信息。让 EditPart<br>自己构建所有东西是可能的（但不是个好主意）。不过这样做并不会导致控制器和视图之间“彻底”分离。EditPart 非常熟悉图形结构，因此以类似的<br>EditPart 重用该结构是不可能的。此外，更改外观或结构可能会导致意想不到的错误。 <br><br>          <br>替代方法是，您应当编写自己的 Figure 子类，该子类掩藏了图形结构的详细信息。然后定义这个子类最少数量的 API，EditPart（控制器）用这些 API 来更新视图。这种实践（称为<br>          <i>关注分离（separation of concerns）</i>）可提高重用机会并使错误更少。<br>          <br><br>          <br><br>        </li><li><br>          <b>不要从图形引用模型或 EditPart</b>。图形不应该具有对 EditPart 或模型的访问权。在某些情形中，EditPart 可能会将自己作为侦听器添加到图形，但是只会认为它是侦听器，而不是 EditPart。这种去耦合（de-coupling）实践也可以产生更多的重用机会。<br>          <br><br>          <br><br>        </li><li><br>          <b>使用内容窗格</b>。<br>有时候您拥有一个容器，该容器将包含其它图形元素，但是您需要在容器四周进行一些装饰。例如，一个 UML<br>类通常显示为框，其顶部标有类名，可能还有一些原型，而底部是为属性和方法保留的。通过组合多个图形可以做到这一点。第一个图形是类的标题框，而另一个图<br>形被指派为 <i>内容窗格</i>。该图形将最终包含表示属性和方法的图形。稍后在编写 EditPart 实现时，并不一定要表明应该将内容窗格用作所有子元素的父元素。<br>        </li></ul><br>      <br><table border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td><img src="http://www.ibm.com/i/v14/rules/blue_rule.gif" alt="" height="1" width="100%"><br><img alt="" src="http://www.ibm.com/i/c.gif" border="0" height="6" width="8"></td></tr></tbody></table><table class="no-print" align="right" cellpadding="0" cellspacing="0"><tbody><tr align="right"><td><img src="http://www.ibm.com/i/c.gif" alt="" height="4" width="100%"><br><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td valign="middle"><img src="http://www.ibm.com/i/v14/icons/u_bold.gif" alt="" border="0" height="16" width="16"><br></td><td align="right" valign="top"><a href="http://www.ibm.com/developerworks/cn/linux/opensource/os-gef/index.html#main" class="fbox" target="_blank" rel="noopener"><b>回页首</b></a></td></tr></tbody></table></td></tr></tbody></table><br><br><p><a name="N10125"><span class="atitle">第 3 步. 编写您的 EditPart - 控制器</span></a></p><br>      <p>接下来我们将利用控制器（即 EditPart）将模型和视图联接起来。该步骤在 GEF 中放置“框架”。所提供的类是抽象的，因此客户实际上必须编写代码。结果证明，生成子类不仅是人们熟悉的方法，而且可能也是将模型映射到视图最灵活和简单的方法。</p><br>      <p>所提供的用于生成子类的基本实现有三种。对于出现在树查看器中的 EditPart 使用<br>        <code>AbstractTreeEditPart</code> 。图形查看器中的继承<br>        <code>AbstractGraphicalEditPart</code> 和<br>        <code>AbstractConnectionEditPart</code> 。本文将着重讨论图形 EditPart。相同的原理同样适用于树查看器。<br>      </p><br>      <p><a name="N1013D"><span class="smalltitle">EditPart 生命周期</span></a></p><br>      <p>在<br>编写您的 EditPart 之前，了解它们来自哪里，以及当不再需要它们时怎样处理它们，这是有帮助的。每个查看器都配置有一个用于创建<br>EditPart<br>的工厂（factory）。当您设置查看器的内容时，通过提供表示该查看器输入的模型对象，可以做到这一点。输入通常是最顶部的模型对象，通过该对象可遍<br>历其它所有对象。然后查看器可以使用自己的工厂来构造用于该输入对象的 <i>内容 EditPart</i>。之后，查看器中的每个 EditPart 将填充和管理其自己的子<br>EditPart（和连接 EditPart），当需要新的 EditPart 时，将委派给 EditPart<br>工厂，直到填充该查看器。当用户添加新的模型对象时，包含这些对象的 EditPart 将通过构造相应的 EditPart<br>做出响应。请注意，视图的构造与 EditPart 的构造是同时进行的。因此，构造每个 EditPart 并将它添加到它的父 EditPart<br>之后，视图（不管是图形还是树项）也会发生同样的过程。 </p><br>      <p>一旦用户除去与某些 EditPart 对应的模型对象，就丢弃这些<br>EditPart。如果用户撤销了一个删除操作，那么用于表示被恢复对象而重新创建的 EditPart 与原先的 EditPart<br>是不同的。这就是为什么 EditPart 不能包含长期信息，以及为什么不应由命令引用的原因。</p><br>      <p><a name="N1014C"><span class="smalltitle">您的第一个 EditPart：内容 EditPart</span></a></p><br>      <p>您编写的第一个 EditPart 是对应于图本身的 EditPart。这个 EditPart 称为查看器的<br>        <i>内容</i>。它对应于模型中最顶部的元素，并且其父元素为查看器的<br>        <i>根</i>EditPart（请参阅图 4）。根通过提供各种图形层（例如连接层和句柄层等）以及可能会在查看器级别提供的视图缩放或其它功能，为内容打下基础。请注意，根的功能不依赖于任何模型对象，GEF 为根提供了几个现成的实现。<br>      </p><br>      <p><br>        <a name="figure4"><br>          <b>图 4. 查看器中的 EditPart</b><br>        </a><br>        <br><br>        <img alt="查看器中的 EditPart" src="http://www.ibm.com/developerworks/cn/linux/opensource/os-gef/fig4.gif" height="231" width="170"><br>      </p><br>      <p>内<br>容的图形不是很有趣，并且它通常只是一个空面板，该面板将包含图的子图。它的图形应该为不透明类型（opaque），并且应当利用布局管理器进行初始化，<br>该布局管理器将对图的子图进行布局。但是，它将拥有结构。图的直系子图是由返回的子模型对象列表确定的。清单 1 显示了一个样本内容<br>EditPart，它创建了一个不透明类型的图形，后者将使用 XYLayout 定位其子图。</p><br>      <br><a name="N10170"><b>清单 1. 内容 EditPart 的初始实现</b></a><br><br>      <table border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td class="code-outline"><pre class="displaycode">public class DiagramContentsEditPart extends AbstractGraphicalEditPart {<br>    protected IFigure createFigure() {<br>        Figure f = new Figure();<br>        f.setOpaque(true);<br>        f.setLayoutManager(new XYLayout());<br>        return f;<br>    }<br>    protected void createEditPolicies() {<br>        …<br>    }<br>    protected List getModelChildren() {<br>        return ((MyModelType)getModel()).getDiagramChildren();<br>    }<br>}<br></pre></td></tr></tbody></table><br><br>      <p>要确定图上的项，需要实现方法<br>        <code>getModelChildren()</code><br>。该方法返回子模型对象的列表（例如图中的节点）。超类将使用这个模型对象列表来创建对应的 EditPart。新创建的 EditPart<br>被添加到部件的子 EditPart 列表。这样又会将每个子 EditPart<br>的图形添加到示例图。缺省情况下，将返回一个空的列表，这表明没有子对象。 </p><br>      <p><a name="N10181"><span class="smalltitle">其它图形 EditPart</span></a></p><br>      <p>其<br>余的 EditPart（表示图中的项）可能拥有要以图形方式显示的数据。它们可能还拥有自己的结构，例如连接或自己的子 EditPart。许多<br>GEF 应用程序利用由标签注明的图标之间的连接来描述这些图标。让我们假定您的 EditPart 将使用 Label<br>作为它的图形，并且您的模型提供了名称、图标以及与标签之间的连接。清单 2 显示了实现这种类型 EditPart 的第一次尝试。</p><br>      <br><a name="N1018A"><b>清单 2. “节点”EditPart 的初始实现</b></a><br><br>      <table border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td class="code-outline"><pre class="displaycode">public class MyNodeEditPart extends AbstractGraphicalEditPart {<br>    protected IFigure createFigure() {<br>        return new Label();<br>    }<br>    protected void createEditPolicies() {<br>        …<br>    }<br>    protected List getModelSourceConnections() {<br>        MyModel node = (MyModel)getModel();<br>        return node.getOutgoingConnections();<br>    }<br>    protected List getModelTargetConnections() {<br>        MyModel node = (MyModel)getModel();<br>        return node.getIncomingConnections();<br>    }<br>    protected void refreshVisuals() {<br>        MyModel node = (MyModel)getModel();<br>        Label label = (Label)getFigure();<br>        label.setText(node.getName());<br>        label.setIcon(node.getIcon());<br>        Rectangle r = new Rectangle(node.x, node.y, -1, -1);<br>        ((GraphicalEditPart) getParent()).setLayoutConstraint(this, label, r);<br>    }<br>}<br></pre></td></tr></tbody></table><br><br>      <p>这里覆盖了一个新方法<br>        <code>refreshVisuals()</code><br>。当需要利用来自模型的数据更新图形时，就调用该方法。在本案例中，模型的名称和图标被反映在标签中。但更为重要的是，该标签是通过将其布局约束传递给父<br>元素来定位的。在内容 EditPart 中，我们使用了 XY 布局管理器。该布局使用 Rectangle<br>约束来确定在何处放置子图形。宽和高的值为“-1”，表明应当为该图提供理想的大小。 </p><br>      <table align="right" border="0" cellpadding="0" cellspacing="0" width="40%"><tbody><tr><td width="10"><img alt="" src="http://www.ibm.com/i/c.gif" height="1" width="10"></td><td><table border="1" cellpadding="5" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#eeeeee"><br>        <a name="N1019D"><b>技巧 #1</b></a><br><br>        <p>决不要使用<br>          <code>setBounds(…)</code> 方法来放置图形。使用诸如 XYLayout 之类的布局管理器确保会正确地更新滚动条。另外，XYLayout 还处理将相对约束转换成绝对位置的工作，并且可用它来将图形自动调整为理想的大小（换而言之，如果约束的宽和高为 -1）。<br>        </p><br>      </td></tr></tbody></table></td></tr></tbody></table><br>      <p>方法<br>        <code>refreshVisuals()</code> 仅在 EditPart 初始化的过程中调用一次，并且决不会被再次调用。在响应模型通知时，应用程序负责根据需要再次调用<br>        <code>refreshVisuals()<br></code> 以更新图形。要改进性能，您可能希望将每个模型属性的代码分解成其自己的方法（或者是一个带有“开关（switch）”的方法）。这样，当模型发出通知时，可以运行最少的代码以便只刷新那些发生更改的内容。<br>      </p><br>      <p>另一个有趣的区别是连接支持的代码。与<br>        <code>getModelChildren()</code> 类似，<br>        <code>getModelSourceConnections()</code> 和<br>        <code>getModelTargetConnections()</code><br>应当返回表示节点之间连接的模型对象。超类在必要时创建对应的 EditPart，并将它们添加到源和目标连接 EditPart<br>列表。请注意，连接是由每端的节点引用的，而其 EditPart 只需创建一次。GEF<br>确保只创建一次连接，该工作是通过首先检查查看器中是否已经存在连接来完成的。 </p><br>      <br><table border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td><img src="http://www.ibm.com/i/v14/rules/blue_rule.gif" alt="" height="1" width="100%"><br><img alt="" src="http://www.ibm.com/i/c.gif" border="0" height="6" width="8"></td></tr></tbody></table><table class="no-print" align="right" cellpadding="0" cellspacing="0"><tbody><tr align="right"><td><img src="http://www.ibm.com/i/c.gif" alt="" height="4" width="100%"><br><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td valign="middle"><img src="http://www.ibm.com/i/v14/icons/u_bold.gif" alt="" border="0" height="16" width="16"><br></td><td align="right" valign="top"><a href="http://www.ibm.com/developerworks/cn/linux/opensource/os-gef/index.html#main" class="fbox" target="_blank" rel="noopener"><b>回页首</b></a></td></tr></tbody></table></td></tr></tbody></table><br><br><p><a name="N101C5"><span class="atitle">建立连接</span></a></p><br>      <p>编写连接 EditPart 实现没有太大的区别。首先生成<br>        <code>AbstractConnectionEditPart</code> 的子类。跟前面一样，可以实现<br>        <code>refreshVisuals()</code> ，以将属性从模型映射到图形。连接可能还拥有约束，尽管这些约束与前面的约束略有不同。这里，连接路由器使用约束来使连接转向（bend）。此外，连接 EditPart 的图形必须是 Draw2D<br>        <code>Connection</code> ，它引入了另一个需求：连接锚（connection anchor）。<br>      </p><br>      <p>连接必须由<br>        <code>ConnectionAnchor</code> “锚定”在两端。因此，必须在连接 EditPart 中或在节点实现中表明使用哪些锚。缺省情况下，GEF 假定节点 EditPart 将通过实现<br>        <code>NodeEditPart<br></code> 接口而提供锚。这样假定的一个原因是，锚的选择取决于各端上的节点正在使用的图形。连接 EditPart<br>不应了解节点正在使用的图形的任何内容。另一个原因是，当用户创建连接时，连接 EditPart<br>是不存在的，因此节点必须能够自己显示反馈。作为清单 2 的延续，我们在清单 3 中添加了必要的锚支持。 </p><br>      <br><a name="N101E5"><b>清单 3. 将锚支持添加到“节点”EditPart</b></a><br><br>      <table border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td class="code-outline"><pre class="displaycode">public class MyNodeEditPart<br>    extends AbstractGraphicalEditPart<br>    implements NodeEditPart<br>{<br>    …<br>    public ConnectionAnchor getSourceConnectionAnchor(ConnectionEditPart connection) {<br>        return new ChopboxAnchor(getFigure());<br>    }<br>    public ConnectionAnchor getSourceConnectionAnchor(Request request) {<br>        return new ChopboxAnchor(getFigure());<br>    }<br>    public ConnectionAnchor getTargetConnectionAnchor(ConnectionEditPart connection) {<br>        return new ChopboxAnchor(getFigure());<br>    }<br>    public ConnectionAnchor getTargetConnectionAnchor(Request request) {<br>        return new ChopboxAnchor(getFigure());<br>    }<br>    …<br>}<br></pre></td></tr></tbody></table><br><br>      <table align="right" border="0" cellpadding="0" cellspacing="0" width="40%"><tbody><tr><td width="10"><img alt="" src="http://www.ibm.com/i/c.gif" height="1" width="10"></td><td><table border="1" cellpadding="5" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#eeeeee"><br>        <a name="N101F1"><b>技巧 #2</b></a><br><br>        <p>别忘记真正实现<br>          <code>NodeEditPart</code> 接口。否则您的方法将永远不会被调用。<br>        </p><br>      </td></tr></tbody></table></td></tr></tbody></table><br>      <p>以<br>连接（connection）为参数的方法是对现有连接 EditPart<br>设置锚时使用的方法。其它两个方法以请求（request）作为参数。这些方法是用户创建新连接时的编辑过程中使用的。对于本示例，所有情形都将返回<br>chopbox 锚。chopbox 锚只查找线与节点图形的边框相交的点。</p><br>      <p>实现连接 EditPart 是比较简单的。请注意，甚至无需创建图形，因为缺省的<br>        <code>PolylineConnection</code> 创建适合于大多数场合（请参阅清单 4）。<br>      </p><br>      <br><a name="N10209"><b>清单 4. 初始的连接 EditPart 实现</b></a><br><br>      <table border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td class="code-outline"><pre class="displaycode">public class MyConnectionEditPart extends AbstractConnectionEditPart {<br>    protected void createEditPolicies() {<br>        …<br>    }<br>    protected void refreshVisuals() {<br>        PolylineConnection figure = (PolylineConnection)getFigure();<br>        MyConnection connx = (MyConnection)getModel();<br>        figure.setForegroundColor(MagicHelper.getConnectionColor(connx));<br>        figure.setRoutingConstraint(MagicHelper.getConnectionBendpoints(connx));<br>    }<br>}<br></pre></td></tr></tbody></table><br><br>      <table align="right" border="0" cellpadding="0" cellspacing="0" width="40%"><tbody><tr><td width="10"><img alt="" src="http://www.ibm.com/i/c.gif" height="1" width="10"></td><td><table border="1" cellpadding="5" cellspacing="0" width="100%"><tbody><tr><td bgcolor="#eeeeee"><br>        <a name="N10215"><b>技巧 #3</b></a><br><br>        <p>最重要的是了解何时使用以及何时不使用 ConnectionEditPart。当用户可以选择某些东西并可与之进行交互的时候，就使用连接 EditPart。它可能与模型中的某个对象直接相关，并且通常可由自己删除。</p><br>        <p>如果您只是拥有一个需要绘制直线的节点或容器，那么只须用图形的 paint 方法绘制直线，或者组合一个图形，该图形包含 Polyline 图形。</p><br>        <p>连接始终都必须拥有源和目标。如果您需要一个连接，该连接可以在没有源或没有目标的情况下存在，那么比较好的方法是只继承<br>          <code>AbstractGraphicalEditPart</code> ，并使用连接图形。<br>        </p><br>      </td></tr></tbody></table></td></tr></tbody></table><br>      <p><a name="N10229"><span class="smalltitle">侦听模型</span></a></p><br>      <p>创<br>建 EditPart 之后，它应该开始侦听来自模型的更改通知。由于 GEF<br>是与模型无关的，因此所有应用程序都必须添加自己的侦听器，并处理产生的通知。接收到通知时，处理程序可以调用某个提供的方法来强制进行一次刷新。例如，<br>如果删除了一个子模型对象，那么调用 <code>refreshChildren()</code> 将导致对应的 EditPart 及其图形被除去。对于简单的属性更改，可以使用<br>        <code>refreshVisuals()</code> 。正如我们前面提及的，可将该方法分解成几个部分，从而避免没有必要地更新每个显示的属性。<br>      </p><br>      <p>添加侦听器但却忘记除去它们是导致内存泄漏的常见原因。出于这个原因，添加和除去侦听器的地方应该在 API 中清晰地注明。您的 EditPart 必须继承<br>        <code>activate()</code> ，以便添加稍后必须除去的任何侦听器。通过继承<br>        <code>deactivate()</code> 可除去那些相同的侦听器。清单 5 显示了向节点 EditPart 实现添加的模型通知内容。<br>      </p><br>      <br><a name="N10245"><b>清单 5. 侦听“节点”EditPart 中的模型更改</b></a><br><br>      <table border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td class="code-outline"><pre class="displaycode">public class MyNodeEditPart<br>extends AbstractGraphicalEditPart<br>    implements NodeEditPart, ModelListener<br>{<br>    …<br>    public void activate() {<br>        super.activate();<br>        ((MyModel)getModel()).addModelListener(this);<br>    }<br>    public void deactivate() {<br>        ((MyModel)getModel()).removeModelListener(this);<br>        super.deactivate();<br>    }<br>    public void modelChanged(ModelEvent event) {<br>        if (event.getChange().equals(“outgoingConnections”))<br>            refreshSourceConnections();<br>        else if (event.getChange().equals(“incomingConnections”))<br>            refreshTargetConnections();<br>        else if (event.getChange().equals(“icon”)<br>          || event.getChange().equals(“name”))<br>            refreshVisuals();<br>    }<br>    …<br>}<br></pre></td></tr></tbody></table><br><br>      <p><a name="N1024F"><span class="smalltitle">编辑模型</span></a></p><br>      <p>到<br>目前为止，我们已经讲解了如何创建<br>EditPart，它们如何创建自己的可视图（visual）以及当模型发生变化时它们如何自我更新。除此之外，EditPart<br>也是对模型进行更改的主要参与者。当命令的请求被发送给 EditPart 时就会发生这种情况。请求还用来要求 EditPart<br>显示诸如在鼠标拖动期间发生的反馈。EditPart 支持、阻止或忽略给定的请求。所支持或阻止的请求类型决定了 EditPart 的行为。</p><br>      <p>到目前为止，侧重点都是将模型的结构和特性映射到视图。结果表明，这基本上是您在 EditPart 类自身中所做的所有工作。其行为是由一组名为<br>        <i>EditPolicies</i> 的可插入的助手类决定的。在所提供的示例中，我们忽略了方法<br>        <code>createEditPolicies()</code> 。一旦您实现该方法，您就几乎已经完成了您的 EditPart。当然，您仍需要提供编辑策略，该策略知道如何修改您应用程序的模型。<br>      </p><br>      <p>因为编辑行为是可插入的，所以在开发各种 EditPart 实现时，可以根据将模型映射到视图和处理模型更新这种任务，来创建类层次结构。</p><br>      <br><table border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td><img src="http://www.ibm.com/i/v14/rules/blue_rule.gif" alt="" height="1" width="100%"><br><img alt="" src="http://www.ibm.com/i/c.gif" border="0" height="6" width="8"></td></tr></tbody></table><table class="no-print" align="right" cellpadding="0" cellspacing="0"><tbody><tr align="right"><td><img src="http://www.ibm.com/i/c.gif" alt="" height="4" width="100%"><br><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td valign="middle"><img src="http://www.ibm.com/i/v14/icons/u_bold.gif" alt="" border="0" height="16" width="16"><br></td><td align="right" valign="top"><a href="http://www.ibm.com/developerworks/cn/linux/opensource/os-gef/index.html#main" class="fbox" target="_blank" rel="noopener"><b>回页首</b></a></td></tr></tbody></table></td></tr></tbody></table><br><br><p><a name="N10265"><span class="atitle">第 4 步. 将所有内容组合在一起</span></a></p><br>      <p>现在，您已经完成了以图形方式显示您的模型所需的所有部分。对于最后的组装，我们将使用<br>        <code>IEditorPart</code><br>。但是，也可以在视图、对话框或者可以放置控件的几乎任何地方使用 GEF 的查看器。对于本步骤，您必须拥有自己的 UI<br>插件，它将为正在打开的资源定义编辑器和文件扩展名。可在同一个插件或一个不同的插件中定义您的模型。您还需要一个预填充的模型，因为目前还没有编辑功<br>能。 </p><br>      <p>提供样本模型数据的方法有几种。对于本示例而言，当编辑器打开时，我们将在代码中创建模型，从而忽略了文<br>件的实际内容。要做到这一点，我们假定已经存在一个测试工厂。或者，您可以创建一个示例向导，该向导用数据对资源进行预填充（普通向导只创建空图）。最<br>后，您可以利用文本编辑器以手工方式编写文档的内容。</p><br>      <p>既然您有了样本模型，那么让我们创建将显示模型的编辑器部件。有一种快速的方法，就是生成子类或复制 GEF 的<br>        <code>GraphicalEditor</code> 。该类创建<br>        <code>ScrollingGraphicalViewer</code><br>的一个实例，并且构造一个画布来充当编辑器的控件。它是一个很方便的类，用来帮助您开始使用 GEF；一个可以正确工作的 Eclipse<br>编辑器需要考虑很多其它事情，例如不利的团队环境（pessimistic team environment）和要删除或移动资源等。 </p><br>      <p><br>清单 6<br>显示了一个样本编辑器实现。有几个必须实现的抽象方法。出于本文所讨论范围的限制，我们将忽略模型持久性和标记。要让您的图出现在图形查看器中，您必须做<br>两件事情。首先，利用自己的 EditPart 工厂配置查看器，以从第 3 步构造 EditPart。然后，将图模型对象传递给查看器。</p><br>      <br><a name="N10283"><b>清单 6. 实现您的编辑器部件（Editor Part）</b></a><br><br>      <table border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td class="code-outline"><pre class="displaycode">public class MyEditor extends GraphicalEditor {<br>    public MyEditor() {<br>        setEditDomain(new DefaultEditDomain(this));<br>    }<br>    protected void configureGraphicalViewer() {<br>        super.configureGraphicalViewer(); //Sets the viewer&apos;s background to System “white”<br>        getGraphicalViewer().setEditPartFactory(new MyGraphicalEditpartFactory());<br>    }<br>    protected void initializeGraphicalViewer() {<br>        getGraphicalViewer().setContents(MagicHelper.constructSampleDiagram());<br>    }<br>    public void doSave(IProgressMonitor monitor) {<br>        …<br>    }<br>    public void doSaveAs() {<br>        …<br>    }<br>    public void gotoMarker(IMarker marker) {<br>        …<br>    }<br>    public boolean isDirty() {<br>        …<br>    }<br>    public boolean isSaveAsAllowed() {<br>        …<br>    }<br>}<br></pre></td></tr></tbody></table><br><br>      <br><table border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td><img src="http://www.ibm.com/i/v14/rules/blue_rule.gif" alt="" height="1" width="100%"><br><img alt="" src="http://www.ibm.com/i/c.gif" border="0" height="6" width="8"></td></tr></tbody></table><table class="no-print" align="right" cellpadding="0" cellspacing="0"><tbody><tr align="right"><td><img src="http://www.ibm.com/i/c.gif" alt="" height="4" width="100%"><br><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td valign="middle"><img src="http://www.ibm.com/i/v14/icons/u_bold.gif" alt="" border="0" height="16" width="16"><br></td><td align="right" valign="top"><a href="http://www.ibm.com/developerworks/cn/linux/opensource/os-gef/index.html#main" class="fbox" target="_blank" rel="noopener"><b>回页首</b></a></td></tr></tbody></table></td></tr></tbody></table><br><br><p><a name="N1028D"><span class="atitle">接下来的步骤</span></a></p><br>      <p>我们已经经历了从仅拥有一个模型到在图形编辑器中显示该模型的全过程。但是我们只打下了基础。我们简要提及了编辑策略。通过阅读与 GEF SDK 一起提供的开发人员文档，可以获得有关编辑策略的更多信息。还可从 GEF 的主页（请参阅文章结尾的<br>        <a href="http://www.ibm.com/developerworks/cn/linux/opensource/os-gef/index.html#resources" target="_blank" rel="noopener">参考资料</a>）获得一个示例，该示例演示了如何使用各种编辑策略类型。<br>      </p><br>      <p>GEF 还提供了一个调色板。该调色板显示了一组工具，用于在图中创建对象。用户可以激活这些工具，或者使用本机拖放直接从该调色板拖动项。它还支持让用户定制内容。</p><br>      <p>在 GEF 中还可以使用几个 JFace 操作。应用程序可以在菜单、工具栏或上下文菜单中使用诸如撤销、对齐和删除之类的操作。</p><br>      <p>最<br>后，您的应用程序应当支持大纲（outline）视图和特性（properties）视图。大纲视图用于导航和有限的编辑用途。GEF 的<br>TreeViewer 和／或概述（overview）窗口可以在这里使用。特性表（property<br>sheet）允许用户查看和编辑任何当前选定项的详细特性。</p><br>      <p>为了显示所选择的项并允许用户进行更改，您必须将编辑策略添加到 EditPart。请参阅 GEF 主页上的示例，并参阅与 GEF SDK 一起提供的开发人员文档。</p><br>      <p>有关 GEF 和 Eclipse 工作台提供的其它功能的详细信息不在本文的讨论范畴之内，但是您可能有兴趣对它们稍做了解：</p><br>      <ul><li><br>          <b>调色板</b>。该工具的调色板是用于在图中创建新对象的<br>          <i>实际</i>方法。GEF 包含了一个功能丰富的调色板，它支持拖放、多绘图程序和布局设置，如果应用程序希望，它甚至可支持让用户定制内容。<br>        </li><li><br>          <b>操作栏</b>。编辑器（Editor）和视图（View）可以为工具栏、菜单和上下文菜单提供操作（Action）。GEF 提供了几个可重用的操作实现，但是将它们显示在什么地方取决于应用程序。<br>        </li><li><br>          <b>特性表</b>。特性表可用于显示所选项特性的详细信息。GEF 允许您在 EditPart 上或在模型中添加特性表支持。<br>        </li><li><br>          <b>大纲</b>。大纲视图通常用于显示图的结构化表示，但是一般来说，它可用于任何工作。GEF 的 TreeViewer 通常在大纲视图中使用。<br>        </li></ul><br>    <br><br><p><a name="resources"><span class="atitle">参考资料 </span></a></p><br>      <ul><li>您可以参阅本文在 developerWorks 全球站点上的<br>          <a href="http://www.ibm.com/developerworks/library/os-gef/index.html?S_TACT=105AGX52&amp;S_CMP=cn-a-l" target="_blank" rel="noopener">英文原文</a>.<br>        <br><br></li><li>请在<br>          <a href="http://www.eclipse.org/gef" target="_blank" rel="noopener">GEF 主页</a>上下载插件并查找有关 GEF 的其它信息。<br>          <br><br>          <br><br>        <br><br></li><li><br>          <a href="news://news.eclipse.org/eclipse.tools.gef" target="_blank" rel="noopener">GEF 新闻组</a>是查找答案和进行提问的极佳场所。<br>          <br><br>          <br><br>        <br><br></li><li><br>          <a href="http://www.eclipse.org/" target="_blank" rel="noopener">Eclipse 项目</a>主管着 Eclipse 工作台、GEF 和其它开放源码技术。<br>          <br><br>          <br><br>        <br><br></li><li>请在<br>          <i>developerWorks</i>上浏览<br>          <a href="http://www.ibm.com/developerworks/views/opensource/articles.jsp?S_TACT=105AGX52&amp;expand&amp;sort_order=desc&amp;search_by&amp;S_CMP=cn-a-l&amp;show_abstract=false&amp;sort_by=Date&amp;view_by=Eclipse" target="_blank" rel="noopener">针对开发人员的其它 Eclipse 文章</a>。<br>          <br><br>          <br><br>        <br></li></ul><br>    <br><br><p><a name="author"><span class="atitle">关于作者</span></a></p><table border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td colspan="3"><img alt="" src="http://www.ibm.com/i/c.gif" height="5" width="100%"></td></tr><tr align="left" valign="top"><td><br></td><td><img alt="" src="http://www.ibm.com/i/c.gif" height="5" width="4"></td><td width="100%"><p>Randy<br>Hudson 是北卡罗来纳州 Research Triangle Park 的 IBM 软件工程师。作为图形编辑框架（Graphical<br>Editing<br>Framework，GEF）的技术领导，他帮助将这个曾经是内部的项目转变成了开放源码技术。他目前的工作侧重于可用性、图形编辑、图形布局和边缘路由<br>（edge routing）。可以通过 <a href="mailto:buchu@nc.rr.com?cc=" target="_blank" rel="noopener">buchu at nc.rr.com</a>与 Randy 联系。<br>      </p></td></tr></tbody></table>&nbsp;<p></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/blog/tags/Java/" rel="tag"># Java</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/blog/cjcuko4v200944urqajz1yzts/" rel="next" title="GEF框架分析之一（转载）">
                <i class="fa fa-chevron-left"></i> GEF框架分析之一（转载）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/blog/cjcuko5vy01zg4urq0cjtlanb/" rel="prev" title="敏捷建模">
                敏捷建模 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Vanessa</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/blog/archives/">
              
                  <span class="site-state-item-count">874</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">224</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Vanessa</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/blog/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/blog/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/blog/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/blog/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/blog/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/blog/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
