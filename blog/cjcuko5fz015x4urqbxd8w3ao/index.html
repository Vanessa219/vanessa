<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/blog/lib/fancybox/source/jquery.fancybox.css" rel="stylesheet" type="text/css" />







<link href="/blog/lib/font-awesome/css/font-awesome.min.css" rel="stylesheet" type="text/css" />

<link href="/blog/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/blog/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Java," />










<meta name="description" content="本章介绍Java的实用工具类库java.util包。在这个包中，Java提供了一些实用的方法和数据结构。例如，Java提供日期(Data)类、日历(Calendar)类来产生和获取日期及时间，提供随机数(Random)类产生各种类型的随机数，还提供了堆栈(Stack)、向量(Vector)&amp;nbsp;、位集合(Bitset)以及哈希表(Hashtable)等类来表示相应的数据结构。　　图1.1给出">
<meta name="keywords" content="Java">
<meta property="og:type" content="article">
<meta property="og:title" content="实用工具类库java.util">
<meta property="og:url" content="https://vanessa.js.org/blog/cjcuko5fz015x4urqbxd8w3ao/index.html">
<meta property="og:site_name" content="Vanessa">
<meta property="og:description" content="本章介绍Java的实用工具类库java.util包。在这个包中，Java提供了一些实用的方法和数据结构。例如，Java提供日期(Data)类、日历(Calendar)类来产生和获取日期及时间，提供随机数(Random)类产生各种类型的随机数，还提供了堆栈(Stack)、向量(Vector)&amp;nbsp;、位集合(Bitset)以及哈希表(Hashtable)等类来表示相应的数据结构。　　图1.1给出">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-01-20T03:46:42.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="实用工具类库java.util">
<meta name="twitter:description" content="本章介绍Java的实用工具类库java.util包。在这个包中，Java提供了一些实用的方法和数据结构。例如，Java提供日期(Data)类、日历(Calendar)类来产生和获取日期及时间，提供随机数(Random)类产生各种类型的随机数，还提供了堆栈(Stack)、向量(Vector)&amp;nbsp;、位集合(Bitset)以及哈希表(Hashtable)等类来表示相应的数据结构。　　图1.1给出">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://vanessa.js.org/blog/cjcuko5fz015x4urqbxd8w3ao/"/>





  <title>实用工具类库java.util | Vanessa</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/blog/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Vanessa</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/blog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/blog/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://vanessa.js.org/blog/blog/cjcuko5fz015x4urqbxd8w3ao/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Vanessa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vanessa">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">实用工具类库java.util</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2008-09-10T05:42:00+08:00">
                2008-09-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>本章介绍Java的实用工具类库java.util包。在这个包中，Java提供了一些实用的方法和数据结构。例如，Java提供日期(Data)类、日历<br>(Calendar)类来产生和获取日期及时间，提供随机数(Random)类产生各种类型的随机数，还提供了堆栈(Stack)、向量<br>(Vector)&nbsp;、位集合(Bitset)以及哈希表(Hashtable)等类来表示相应的数据结构。<br>　　图1.1给出了java.util包的基本层次结构图。下面我们将具体介绍其中几个重要的类。<br>　　　　　　　　　　　┌java.util.BitSet<br>　　　　　　　　　　　│java.util.Calendar<br>　　　　　　　　　　　│　　　　　　└java.util.GregorianCalendar<br>　　　　　　　　　　　│java.util.Date<br>　　　　　　　　　　　│java.util.Dictionary<br>　　　　　　　　　　　│　　　　　　└java.util.Hashtable<br>　　　　　　　　　　　│　　　　　　　　　　　　　└java.util.Properties<br>　　　　　　　　　　　│java.util.EventObject<br>　　　　　　　　　　　│java.util.ResourceBundle<br>　　　　　　　┌普通类┤　　　　　　├java.util.ListResourceBundle<br>　　　　　　　│　　　│　　　　　　└java.util.PropertyResourceBundle<br>　　　　　　　│　　　│java.util.Local<br>　　　　　　　│　　　│java.util.Observable<br>　　　　　　　│　　　│java.util.Random<br>　　　　　　　│　　　│java.util.StringTokenizer<br>　　　　　　　│　　　│java.util.Vector<br>　　　　　　　│　　　│　　　　　　└java.util.Stack<br>　　Java.util┤　　　└java.util.TimeZone<br>　　　　　　　│　　　　　　　　　　└java.util.SimpleTimeZone<br>　　　　　　　│　　　┌java.util.Enumeration<br>　　　　　　　├接　口┤java.util.EventListener<br>　　　　　　　│　　　└java.util.Observer<br>　　　　　　　│　　　┌java.util.EmptyStackException<br>　　　　　　　└异常类┤java.util.MissingResourceException<br>　　　　　　　　　　　│java.util.NoSuchElementException<br>　　　　　　　　　　　└java.util.TooManyListenersException<br>　　　　　　　图1.1&nbsp;java.util包的基本层次结构<br><br><br>1.2&nbsp;日期类Date<br><br>　　Java在日期类中封装了有关日期和时间的信息，用户可以通过调用相应的方法来获取系统时间或设置日期和时间。Date类中有很多方法在JDK1.0公布后已经过时了，在8.3中我们将介绍JDK1.0中新加的用于替代Date的功能的其它类。<br>　　在日期类中共定义了六种构造函数。<br>　　(1)public&nbsp;Date()<br>　　创建的日期类对象的日期时间被设置成创建时刻相对应的日期时间。<br>　　例&nbsp;Date&nbsp;today=new&nbsp;Date()；//today被设置成创建时刻相对应的日期时间。<br>　　(2)public&nbsp;Date&nbsp;(long&nbsp;date)<br>　　long&nbsp;型的参数date可以通过调用Date类中的static方法parse(String&nbsp;s)来获得。<br>　　例&nbsp;long&nbsp;l=Date.parse(“Mon&nbsp;6&nbsp;Jan&nbsp;1997&nbsp;13:3:00”);<br>　　　　Date&nbsp;day=new&nbsp;Date(l);<br>　　//day中时间为1997年&nbsp;1月6号星期一，13:3:00。<br>　　(3)public&nbsp;Date(String&nbsp;s)<br>　　按字符串s产生一日期对象。s的格式与方法parse中字符串参数的模式相同。<br>　　例&nbsp;Date&nbsp;day=new&nbsp;Date(“Mon&nbsp;6&nbsp;Jan&nbsp;1997&nbsp;13:3:00”);<br>　　//day&nbsp;中时间为1997年1月6号星期一，13:3:00.<br>　　(4)public&nbsp;Date(int&nbsp;year,int&nbsp;month,int&nbsp;date)<br>　　(5)public&nbsp;Date(int&nbsp;year,int&nbsp;month,int&nbsp;date,int&nbsp;hrs,int&nbsp;min)<br>　　(6)public&nbsp;Date(int&nbsp;year,int&nbsp;month,int&nbsp;date,int&nbsp;hrs,int&nbsp;min,int&nbsp;sec)<br>　　按给定的参数创建一日期对象。<br>　　参数说明：<br>　　year的值为：需设定的年份-1900。例如需设定的年份是1997则year的值应为97，即1997-1900的结果。所以Date中可设定的年份最小为1900；<br>　　month的值域为0～11，0代表1月，11表代表12月；<br>　　date的值域在1～31之间；<br>　　hrs的值域在0～23之间。从午夜到次日凌晨1点间hrs=0，从中午到下午1点间hrs=12；<br>　　min和sec的值域在0～59之间。<br>　　例&nbsp;Date&nbsp;day=new&nbsp;Date(11,3,4);<br>　　//day中的时间为：04-Apr-11&nbsp;12:00:00&nbsp;AM<br>另外，还可以给出不正确的参数。<br>　　例　设定时间为1910年2月30日，它将被解释成3月2日。<br>　　Date&nbsp;day=new&nbsp;Date(10,1,30,10,12,34);<br>　　System.out.println(“Day’s&nbsp;date&nbsp;is:”+day);<br>　　//打印结果为：Day’s&nbsp;date&nbsp;is:Web&nbsp;Mar&nbsp;02&nbsp;10:13:34&nbsp;GMT+08:00&nbsp;1910<br>　　下面我们给出一些Date类中常用方法。<br>　　(1)public&nbsp;static&nbsp;long&nbsp;UTC(int&nbsp;year,int&nbsp;month,int&nbsp;date,int&nbsp;hrs.&nbsp;int&nbsp;min,int&nbsp;sec)<br>　　该方法将利用给定参数计算UTC值。UTC是一种计时体制，与GMT(格林威治时间)的计时体系略有差别。UTC计时体系是基于原子时钟的，而GTMT计时体系是基于天文学观测的。计算中使用的一般为GMT计时体系。<br>　　(2)public&nbsp;static&nbsp;long&nbsp;parse(String&nbsp;s)<br>　　该方法将字符串s转换成一个long型的日期。在介绍构造方法Date(long&nbsp;date)时曾使用过这个方法。<br>　　字符串s有一定的格式，一般为：<br>　　(星期&nbsp;日&nbsp;年&nbsp;时间GMT+时区)<br>　　若不注明时区，则为本地时区。<br>　　(3)public&nbsp;void&nbsp;setMonth(int&nbsp;month)<br>　　(4)public&nbsp;int&nbsp;getMonth()<br>　　这两个方法分别为设定和获取月份值。<br>　　获取的月份的值域为0～11，0代表1月，11代表12月。<br>　　(5)public&nbsp;String&nbsp;toString()<br>　　(6)public&nbsp;String&nbsp;toLocalString()<br>　　(7)public&nbsp;String&nbsp;toGMTString()<br>　　将给定日期对象转换成不同格式的字符串。它们对应的具体的格式可参看例子8.1。<br>　　(8)public&nbsp;int&nbsp;getTimezoneOffset()<br>　　该方法用于获取日期对象的时区偏移量。<br>　<br>　例8.1中对上面介绍的Date类中的基本方法进行了具体的应用，并打印了相应的结果。由于使用了一些过时的方法，所以编译时会有警告信息。另外，由于<br>本例中的时间表示与平台有关，不同的JDK版本对此处理不完全相同，因此不同版本的JDK执行本例的结果可能有细微差异。<br>　　例1.1&nbsp;DateApp.java<br>　　import&nbsp;java.lang.System;<br>　　import&nbsp;java.util.Date;<br>　　public&nbsp;class&nbsp;DateApp{<br>　　　public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[]){<br>　　　　Date&nbsp;today=new&nbsp;Date();<br>　　　　//today中的日期被设成创建时刻的日期和时间，假设创建时刻为1997年3月<br>　　　　//23日17时51分54秒。<br>　　　　System.out.println(“Today’s&nbsp;date&nbsp;is&nbsp;”+today);<br>　　　　//返回一般的时间表示法，本例中结果为<br>　　　　//Today’s&nbsp;date&nbsp;is&nbsp;Fri&nbsp;May&nbsp;23&nbsp;17:51:54&nbsp;1997<br>　　　　System.out.println(“Today’s&nbsp;date(Internet&nbsp;GMT)is:”<br>　　　　　+today.toGMTString());<br>　　　　//返回结果为GMT时间表示法，本例中结果为<br>　　　　//Today’s&nbsp;date(Internet&nbsp;GMT)is:&nbsp;23&nbsp;May&nbsp;1997&nbsp;09:51:54:GMT<br>　　　　System.out.println(“Today’s&nbsp;date(Locale)&nbsp;is:”<br>　　　　　+today.toLocaleString());<br>　　　　//返回结果为本地习惯的时间表示法，结果为<br>　　　　//Today’s&nbsp;date(Locale)is:05/23/97&nbsp;17:51:54<br>　　　　System.out.println(“Today’s&nbsp;year&nbsp;is:&nbsp;”+today.getYear());<br>　　　　System.out.println(“Today’s&nbsp;month&nbsp;is:&nbsp;”+(today.getMonth()+1));<br>　　　　System.out.println(“Today’s&nbsp;date&nbsp;is:&nbsp;”+today.getDate());<br>　　　　//调用Date类中方法，获取年月日的值。<br>　　　　//下面调用了不同的构造方法来创建Date类的对象。<br>　　　　Date&nbsp;day1=new&nbsp;Date(100,1,23,10,12,34);<br>　　　　System.out.println(“Day1’s&nbsp;date&nbsp;is:&nbsp;”+day1);<br>　　　　Date&nbsp;day2=new&nbsp;Date(“Sat&nbsp;12&nbsp;Aug&nbsp;1996&nbsp;13:3:00”);<br>　　　　System.out.println(“Day2’s&nbsp;date&nbsp;is:&nbsp;”+day2);<br>　　　　long&nbsp;l=&nbsp;Date.parse(“Sat&nbsp;5&nbsp;Aug&nbsp;1996&nbsp;13:3:00&nbsp;GMT+0800”);<br>　　　　Date&nbsp;day3=&nbsp;new&nbsp;Date(l);<br>　　　　System.out.println(“Day3’s&nbsp;date(GMT)is:&nbsp;”+day3.toGMTString());<br>　　　　System.out.println(“Day3’s&nbsp;date(Locale)is:&nbsp;”<br>　　　　　+day3.toLocaleString());<br>　　　　System.out.println(“Day3’s&nbsp;time&nbsp;zone&nbsp;offset&nbsp;is:”<br>　　　　　+day3.getTimezoneOffset());<br>　　　}<br>　　}<br><br>　　运行结果(JDK1.3版，与原文不同，原文是JDK1.0版)：<br>　　E:\java\tutorial\java01&gt;java&nbsp;DateApp<br>　　Today’s&nbsp;date&nbsp;is&nbsp;Thu&nbsp;Dec&nbsp;27&nbsp;17:58:16&nbsp;CST&nbsp;2001<br>　　Today’s&nbsp;date(Internet&nbsp;GMT)is:27&nbsp;Dec&nbsp;2001&nbsp;09:58:16&nbsp;GMT<br>　　Today’s&nbsp;date(Locale)&nbsp;is:2001-12-27&nbsp;17:58:16<br>　　Today’s&nbsp;year&nbsp;is:&nbsp;101<br>　　Today’s&nbsp;month&nbsp;is:&nbsp;12<br>　　Today’s&nbsp;date&nbsp;is:&nbsp;27<br>　　Day1’s&nbsp;date&nbsp;is:&nbsp;Wed&nbsp;Feb&nbsp;23&nbsp;10:12:34&nbsp;CST&nbsp;2000<br>　　Day2’s&nbsp;date&nbsp;is:&nbsp;Fri&nbsp;Aug&nbsp;12&nbsp;13:03:00&nbsp;CST&nbsp;1996<br>　　Day3’s&nbsp;date(GMT)is:&nbsp;5&nbsp;Aug&nbsp;1996&nbsp;05:03:00&nbsp;GMT<br>　　Day3’s&nbsp;date(Locale)is:&nbsp;1996-8-5&nbsp;13:03:00<br>　　Day3’s&nbsp;time&nbsp;zone&nbsp;offset&nbsp;is:-480<br><br>　　E:\java\tutorial\java01&gt;<br><br>1.3&nbsp;日历类Calendar<br><br>　<br>　在早期的JDK版本中，日期(Date)类附有两大功能：(1)允许用年、月、日、时、分、秒来解释日期：(2)允许对表示日期的字符串进行格式化和句<br>法分析。在JDK1.1中提供了类Calendar来完成第一种功能，类DateFormat来完成第二项功能。dateFormat是<br>java.text包中的一个类。与Date类有所不同的是，DateFormat类接受用各种语言和不同习惯表示的日期字符串。本节将介绍<br>java.util包中的类Calendar及其它新增加的相关的类。<br>　　类Calendar是一个抽象类，它完成日期(Date)类和普通日期表示法(即用一组整型域如YEAR，MONTH，DAY，HOUR表示日期)之间的转换。<br>　<br>　由于所使用的规则不同，不同的日历系统对同一个日期的解释有所不同。在JDK1.1中提供了Calendar类一个子类<br>GregorianCalendar??它实现了世界上普遍使用的公历系统。当然用户也可以通过继承Calendar类，并增加所需规则，以实现不同的日<br>历系统。<br>　　第GregorianCalendar继承了Calendar类。本节将在介绍类GregorianCalendar的同时顺带介绍Calendar类中的相关方法。<br>　　类GregorianCalendar提供了七种构造函数：<br>　　(1)public&nbsp;GregorianCalendar()<br>　　创建的对象中的相关值被设置成指定时区，缺省地点的当前时间，即程序运行时所处的时区、地点的当前时间。<br>　　(2)public&nbsp;GregorianCalendar(TimeZone&nbsp;zone)<br>　　创建的对象中的相关值被设置成指定时区zone，缺省地点的当前时间。<br>　　(3)public&nbsp;GregorianCalendar(Locale&nbsp;aLocale)<br>　　创建的对象中的相关值被设置成缺省时区，指定地点aLocale的当前时间。<br>　　(4)public&nbsp;GregorianCalendar(TimeZone&nbsp;zone,Local&nbsp;aLocale)<br>　　创建的对象中的相关值被设置成指定时区，指定地点的当前时间。<br>　　上面使用到的类TimeZone的性质如下：<br>　　TimeZone是java.util包中的一个类，其中封装了有关时区的信息。每一个时区对应一组ID。类TimeZone提供了一些方法完成时区与对应ID两者之间的转换。<br>　　(Ⅰ)已知某个特定的ID，可以调用方法<br>　　public&nbsp;static&nbsp;synchronized&nbsp;TimeZone&nbsp;getTimeZone(String&nbsp;ID)<br>来获取对应的时区对象。<br>　　例&nbsp;太平洋时区的ID为PST，用下面的方法可获取对应于太平洋时区的时区对象：<br>　　TimeZone&nbsp;tz=TimeZone.getTimeZone(“PST”);<br>　　调用方法getDefault()可以获取主机所处时区的对象。<br>　　TimeZone&nbsp;tz=TimeZone.getDefault();<br>　　(Ⅱ)调用以下方法可以获取时区的ID<br>　　■public&nbsp;static&nbsp;synchronized&nbsp;String[]&nbsp;getavailableIDs(int&nbsp;rawOffset)<br>　　根据给定时区偏移值获取ID数组。同一时区的不同地区的ID可能不同，这是由于不同地区对是否实施夏时制意见不统一而造成的。<br>　　例String&nbsp;s[]=TimeZone.getAvailableIDs(-7<em>60</em>60<em>1000);<br>　　打印s，结果为s[0]=PNT，s[1]=MST<br>　　■public&nbsp;static&nbsp;synchronized&nbsp;String[]&nbsp;getAvailableIDs()<br>　　获取提供的所有支持的ID。<br>　　■public&nbsp;String&nbsp;getID()<br>　　获取特定时区对象的ID。<br>　　例&nbsp;TimeZone&nbsp;tz=TimeZone.getDefault();<br>　　String&nbsp;s=tz.getID();<br>　　打印s，结果为s=CTT。<br>　　上面使用类的对象代表了一个特定的地理、政治或文化区域。Locale只是一种机制，它用来标识一类对象，Local本身并不包含此类对象。<br>　　要获取一个Locale的对象有两种方法：<br>　　(Ⅰ)调用Locale类的构造方法<br>　　Locale(String&nbsp;language,String&nbsp;country)<br>　　Locale(String&nbsp;language,String&nbsp;country,String&nbsp;variant)<br>　　参数说明：language??在ISO-639中定义的代码，由两个小写字母组成。<br>　　　　　　　country??在ISO-3166中定义的代码，由两个大写字母组成。<br>　　　　　　　variant??售货商以及特定浏览器的代码，例如使用WIN代表Windows。<br>　　(Ⅱ)调用Locale类中定义的常量<br>　　Local类提供了大量的常量供用户创建Locale对象。<br>　　例&nbsp;Locale.CHINA<br>　　　　为中国创建一个Locale的对象。<br>　　类TimeZone和类Locale中的其它方法，读者可查阅API。<br>　　(5)public&nbsp;GregorianCalendar(int&nbsp;year,int&nbsp;month,int&nbsp;date)<br>　　(6)public&nbsp;GregorianCalendar(int&nbsp;year,int&nbsp;month,int&nbsp;date,int&nbsp;hour,int&nbsp;minute)<br>　　(7)public&nbsp;GregorianCalendar(int&nbsp;year,int&nbsp;month,int&nbsp;date,int&nbsp;hour,int&nbsp;minute,int&nbsp;second)<br>　　用给定的日期和时间创建一个GregorianCalendar的对象。<br>　　参数说明：<br>　　year-设定日历对象的变量YEAR；month-设定日历对象的变量MONTH；<br>　　date-设定日历对象的变量DATE；hour-设定日历对象的变量HOUR_OF_DAY；<br>　　minute-设定日历对象的变量MINUTE；second-设定日历对象的变量SECOND。<br>　　与Date类中不同的是year的值没有1900这个下限，而且year的值代表实际的年份。month的含义与Date类相同，0代表1月，11代表12月。<br>　　例&nbsp;GregorianCalendar&nbsp;cal=new&nbsp;GregorianCalendar(1991,2,4)<br>　　cal的日期为1991年3月4号。<br>　<br>　除了与Date中类似的方法外，Calendar类还提供了有关方法对日历进行滚动计算和数学计算。计算规则由给定的日历系统决定。进行日期计算时，有<br>时会遇到信息不足或信息不实等特殊情况。Calendar采取了相应的方法解决这些问题。当信息不足时将采用缺省设置，在<br>GregorianCalendar类中缺省设置一般为YEAR=1970,MONTH=JANUARY,DATE=1。<br>　　当信息不实时，Calendar将按下面的次序优先选择相应的Calendar的变量组合，并将其它有冲突的信息丢弃。<br>　　MONTH+DAY_OF_MONTH<br>　　MONTH+WEEK_OF_MONTH+DAY_OF_WEEK<br>　　MONTH+DAY_OF_WEEK_OF_MONTH+DAY_OF_WEEK<br>　　DAY_OF+YEAR<br>　　DAY_OF_WEEK_WEEK_OF_YEAR<br>　　HOUR_OF_DAY<br><br>1.4&nbsp;随机数类Random<br><br>　<br>　Java实用工具类库中的类java.util.Random提供了产生各种类型随机数的方法。它可以产生int、long、float、double<br>以及Goussian等类型的随机数。这也是它与java.lang.Math中的方法Random()最大的不同之处，后者只产生double型的随机<br>数。<br>　　类Random中的方法十分简单，它只有两个构造方法和六个普通方法。<br>　　构造方法：<br>　　(1)public&nbsp;Random()<br>　　(2)public&nbsp;Random(long&nbsp;seed)<br>　　Java产生随机数需要有一个基值seed，在第一种方法中基值缺省，则将系统时间作为seed。<br>　　普通方法：<br>　　(1)public&nbsp;synonronized&nbsp;void&nbsp;setSeed(long&nbsp;seed)<br>　　该方法是设定基值seed。<br>　　(2)public&nbsp;int&nbsp;nextInt()<br>　　该方法是产生一个整型随机数。<br>　　(3)public&nbsp;long&nbsp;nextLong()<br>　　该方法是产生一个long型随机数。<br>　　(4)public&nbsp;float&nbsp;nextFloat()<br>　　该方法是产生一个Float型随机数。<br>　　(5)public&nbsp;double&nbsp;nextDouble()<br>　　该方法是产生一个Double型随机数。<br>　　(6)public&nbsp;synchronized&nbsp;double&nbsp;nextGoussian()<br>　　该方法是产生一个double型的Goussian随机数。<br>　　例1.2&nbsp;RandomApp.java。<br>　　//import&nbsp;java.lang.</em>;<br>　　import&nbsp;java.util.Random;<br><br>　　public&nbsp;class&nbsp;RandomApp{<br>　　　public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[]){<br>　　　　Random&nbsp;ran1=new&nbsp;Random();<br>　　　　Random&nbsp;ran2=new&nbsp;Random(12345);<br>　　　　//创建了两个类Random的对象。<br>　　　　System.out.println(“The&nbsp;1st&nbsp;set&nbsp;of&nbsp;random&nbsp;numbers:”);<br>　　　　System.out.println(“\t&nbsp;Integer:”+ran1.nextInt());<br>　　　　System.out.println(“\t&nbsp;Long:”+ran1.nextLong());<br>　　　　System.out.println(“\t&nbsp;Float:”+ran1.nextFloat());<br>　　　　System.out.println(“\t&nbsp;Double:”+ran1.nextDouble());<br>　　　　System.out.println(“\t&nbsp;Gaussian:”+ran1.nextGaussian());<br>　　　　//产生各种类型的随机数<br>　　　　System.out.print(“The&nbsp;2nd&nbsp;set&nbsp;of&nbsp;random&nbsp;numbers:”);<br>　　　　for(int&nbsp;i=0;i&lt;5;i++){<br>　　　　　System.out.println(ran2.nextInt()+”&nbsp;”);<br>　　　　　if(i==2)&nbsp;System.out.println();<br>　　　　　//产生同种类型的不同的随机数。<br>　　　　　System.out.println();//原文如此<br>　　　　}<br>　　　}<br>　　}<br><br>　　运行结果：<br>　　E:\java01&gt;java&nbsp;RandomApp<br>　　The&nbsp;1st&nbsp;set&nbsp;of&nbsp;random&nbsp;numbers:<br>　　　　Integer:-173899656<br>　　　　Long:8056223819738127077<br>　　　　Float:0.6293638<br>　　　　Double:0.7888394520265607<br>　　　　Gaussian:0.5015701094568733<br>　　The&nbsp;2nd&nbsp;set&nbsp;of&nbsp;random&nbsp;numbers:1553932502<br>　　-2090749135<br>　　-287790814<br>　　-355989640<br>　　-716867186<br>　　E:\java01&gt;<br><br>1.5&nbsp;向量类Vector<br><br>　<br>　Java.util.Vector提供了向量(Vector)类以实现类似动态数组的功能。在Java语言中。正如在一开始就提到过，是没有指针概念<br>的，但如果能正确灵活地使用指针又确实可以大大提高程序的质量，比如在C、C++中所谓“动态数组”一般都由指针来实现。为了弥补这点缺陷，Java提供<br>了丰富的类库来方便编程者使用，Vector类便是其中之一。事实上，灵活使用数组也可完成向量类的功能，但向量类中提供的大量方法大大方便了用户的使<br>用。<br>　　创建了一个向量类的对象后，可以往其中随意地插入不同的类的对象，既不需顾及类型也不需预先选定向量的容量，并可方便地进行查找。对于预先不知或不愿预先定义数组大小，并需频繁进行查找、插入和删除工作的情况，可以考虑使用向量类。<br>　　向量类提供了三种构造方法：<br>　　public&nbsp;vector()<br>　　public&nbsp;vector(int&nbsp;initialcapacity,int&nbsp;capacityIncrement)<br>　　public&nbsp;vector(int&nbsp;initialcapacity)<br>　<br>　使用第一种方法，系统会自动对向量对象进行管理。若使用后两种方法，则系统将根据参数initialcapacity设定向量对象的容量(即向量对象可<br>存储数据的大小)，当真正存放的数据个数超过容量时，系统会扩充向量对象的存储容量。参数capacityIncrement给定了每次扩充的扩充值。当<br>capacityIncrement为0时，则每次扩充一倍。利用这个功能可以优化存储。<br>　　在Vector类中提供了各种方法方便用户使用：<br>　　■插入功能<br>　　(1)public&nbsp;final&nbsp;synchronized&nbsp;void&nbsp;addElement(Object&nbsp;obj)<br>　　将obj插入向量的尾部。obj可以是任何类的对象。对同一个向量对象，可在其中插入不同类的对象。但插入的应是对象而不是数值，所以插入数值时要注意将数值转换成相应的对象。<br>　　例&nbsp;要插入一个整数1时，不要直接调用v1.addElement(1)，正确的方法为：<br>　　Vector&nbsp;v1=new&nbsp;Vector();<br>　　Integer&nbsp;integer1=new&nbsp;Integer(1);<br>　　v1.addElement(integer1);<br>　　(2)public&nbsp;final&nbsp;synchronized&nbsp;void&nbsp;setElementAt(object&nbsp;obj,int&nbsp;index)<br>　　将index处的对象设成obj，原来的对象将被覆盖。<br>　　(3)public&nbsp;final&nbsp;synchronized&nbsp;void&nbsp;insertElementAt(Object&nbsp;obj,int&nbsp;index)<br>　　在index指定的位置插入obj，原来对象以及此后的对象依次往后顺延。<br>　　■删除功能<br>　　(1)public&nbsp;final&nbsp;synchronized&nbsp;void&nbsp;removeElement(Object&nbsp;obj)<br>　　从向量中删除obj。若有多个存在，则从向量头开始试，删除找到的第一个与obj相同的向量成员。<br>　　(2)public&nbsp;final&nbsp;synchronized&nbsp;void&nbsp;removeAllElement()<br>　　删除向量中所有的对象。<br>　　(3)public&nbsp;final&nbsp;synchronized&nbsp;void&nbsp;removeElementlAt(int&nbsp;index)<br>　　删除index所指的地方的对象。<br>　　■查询搜索功能<br>　　(1)public&nbsp;final&nbsp;int&nbsp;indexOf(Object&nbsp;obj)<br>　　从向量头开始搜索obj&nbsp;,返回所遇到的第一个obj对应的下标，若不存在此obj，返回-1。<br>　　(2)public&nbsp;final&nbsp;synchronized&nbsp;int&nbsp;indexOf(Object&nbsp;obj,int&nbsp;index)<br>　　从index所表示的下标处开始搜索obj。<br>　　(3)public&nbsp;final&nbsp;int&nbsp;lastIndexOf(Object&nbsp;obj)<br>　　从向量尾部开始逆向搜索obj。<br>　　(4)public&nbsp;final&nbsp;synchronized&nbsp;int&nbsp;lastIndexOf(Object&nbsp;obj,int&nbsp;index)<br>　　从index所表示的下标处由尾至头逆向搜索obj。<br>　　(5)public&nbsp;final&nbsp;synchronized&nbsp;Object&nbsp;firstElement()<br>　　获取向量对象中的首个obj。<br>　　(6)public&nbsp;final&nbsp;synchronized&nbsp;Object&nbsp;lastelement()<br>　　获取向量对象中的最后一个obj。<br>　　了解了向量的最基本的方法后，我们来看一下例8.3VectorApp.java。<br>　　例1.3&nbsp;VectorApp.java。<br>　　import&nbsp;java.util.Vector;<br>　　import&nbsp;java.lang.<em>;//这一句不应该要，但原文如此<br>　　import&nbsp;java.util.Enumeration;<br>　　public&nbsp;class&nbsp;VectorApp{<br>　　　public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args){<br>　　　　Vector&nbsp;v1=new&nbsp;Vector();<br>　　　　Integer&nbsp;integer1=new&nbsp;Integer(1);<br>　　　　v1.addElement(“one”);<br>　　　　//加入的为字符串对象<br>　　　　v1.addElement(integer1);<br>　　　　v1.addElement(integer1);<br>　　　　//加入的为Integer的对象<br>　　　　v1.addElement(“two”);<br>　　　　v1.addElement(new&nbsp;Integer(2));<br>　　　　v1.addElement(integer1);<br>　　　　v1.addElement(integer1);<br>　　　　System.out.println(“The&nbsp;vector&nbsp;v1&nbsp;is:\n\t”+v1);<br>　　　　//将v1转换成字符串并打印<br>　　　　v1.insertElementAt(“three”,2);<br>　　　　v1.insertElementAt(new&nbsp;Float(3.9),3);<br>　　　　System.out.println(“The&nbsp;vector&nbsp;v1(used&nbsp;method&nbsp;insertElementAt())&nbsp;is:\n\t&nbsp;”+v1);<br>　　　　//往指定位置插入新的对象，指定位置后的对象依次往后顺延<br>　　　　v1.setElementAt(“four”,2);<br>　　　　System.out.println(“The&nbsp;vector&nbsp;v1(used&nbsp;method&nbsp;setElementAt())&nbsp;is:\n\t&nbsp;”+v1);<br>　　　　//将指定位置的对象设置为新的对象<br>　　　　v1.removeElement(integer1);<br>　　　　//从向量对象v1中删除对象integer1由于存在多个integer1所以从头开始<br>　　　　//找，删除找到的第一个integer1<br>　　　　Enumeration&nbsp;enum=v1.elements();<br>　　　　System.out.print(“The&nbsp;vector&nbsp;v1(used&nbsp;method&nbsp;removeElement())is:”);<br>　　　　while(enum.hasMoreElements())<br>　　　　System.out.print(enum.nextElement()+”&nbsp;”);<br>　　　　System.out.println();<br>　　　　//使用枚举类(Enumeration)的方法来获取向量对象的每个元素<br>　　　　System.out.println(“The&nbsp;position&nbsp;of&nbsp;object&nbsp;1(top-to-bottom):”<br>　　　　　+&nbsp;v1.indexOf(integer1));<br>　　　　System.out.println(“The&nbsp;position&nbsp;of&nbsp;object&nbsp;1(tottom-to-top):”<br>　　　　　+v1.lastIndexOf(integer1));<br>　　　　//按不同的方向查找对象integer1所处的位置<br>　　　　v1.setSize(4);<br>　　　　System.out.println(“The&nbsp;new&nbsp;vector(resized&nbsp;the&nbsp;vector)is:”+v1);<br>　　　　//重新设置v1的大小，多余的元素被行弃<br>　　　}<br>　　}<br>　　运行结果：<br>　　E:\java01&gt;java&nbsp;VectorApp<br>　　The&nbsp;vector&nbsp;v1&nbsp;is:<br>　　　　　[one,&nbsp;1,&nbsp;1,&nbsp;two,&nbsp;2,&nbsp;1,&nbsp;1]<br>　　The&nbsp;vector&nbsp;v1(used&nbsp;method&nbsp;insertElementAt())&nbsp;is:<br>　　　　　[one,&nbsp;1,&nbsp;three,&nbsp;3.9,&nbsp;1,&nbsp;two,&nbsp;2,&nbsp;1,&nbsp;1]<br>　　The&nbsp;vector&nbsp;v1(used&nbsp;method&nbsp;setElementAt())&nbsp;is:<br>　　　　　[one,&nbsp;1,&nbsp;four,&nbsp;3.9,&nbsp;1,&nbsp;two,&nbsp;2,&nbsp;1,&nbsp;1]<br>　　The&nbsp;vector&nbsp;v1(used&nbsp;method&nbsp;removeElement())is:one&nbsp;four&nbsp;3.9&nbsp;1&nbsp;two&nbsp;2&nbsp;1&nbsp;1<br>　　The&nbsp;position&nbsp;of&nbsp;object&nbsp;1(top-to-bottom):3<br>　　The&nbsp;position&nbsp;of&nbsp;object&nbsp;1(tottom-to-top):7<br>　　The&nbsp;new&nbsp;vector(resized&nbsp;the&nbsp;vector)is:[one,&nbsp;four,&nbsp;3.9,&nbsp;1]<br>　　E:\java01&gt;<br>　　从例1.3运行的结果中可以清楚地了解上面各种方法的作用，另外还有几点需解释。<br>　　(1)类Vector定义了方法<br>　　public&nbsp;final&nbsp;int&nbsp;size()<br>　　此方法用于获取向量元素的个数。它的返回值是向是中实际存在的元素个数，而非向量容量。可以调用方法capactly()来获取容量值。<br>　　方法：<br>　　public&nbsp;final&nbsp;synchronized&nbsp;void&nbsp;setsize(int&nbsp;newsize)<br>　　此方法用来定义向量大小。若向量对象现有成员个数已超过了newsize的值，则超过部分的多余元素会丢失。<br>　　(2)程序中定义了Enumeration类的一个对象<br>　　Enumeration是java.util中的一个接口类，在Enumeration中封装了有关枚举数据集合的方法。<br>　　在Enumeration中提供了方法hawMoreElement()来判断集合中是束还有其它元素和方法nextElement()来获取下一个元素。利用这两个方法可以依次获得集合中元素。<br>　　Vector中提供方法：<br>　　public&nbsp;final&nbsp;synchronized&nbsp;Enumeration&nbsp;elements()<br>　　此方法将向量对象对应到一个枚举类型。java.util包中的其它类中也大都有这类方法，以便于用户获取对应的枚举类型。<br><br>1.6&nbsp;栈类Stack<br><br>　　Stack类是Vector类的子类。它向用户提供了堆栈这种高级的数据结构。栈的基本特性就是先进后出。即先放入栈中的元素将后被推出。Stack类中提供了相应方法完成栈的有关操作。<br>　　基本方法：<br>　　public&nbsp;Object&nbsp;push(Object&nbsp;Hem)<br>　　将Hem压入栈中，Hem可以是任何类的对象。<br>　　public&nbsp;Object&nbsp;pop()<br>　　弹出一个对象。<br>　　public&nbsp;Object&nbsp;peek()<br>　　返回栈顶元素，但不弹出此元素。<br>　　public&nbsp;int&nbsp;search(Object&nbsp;obj)<br>　　搜索对象obj,返回它所处的位置。<br>　　public&nbsp;boolean&nbsp;empty()<br>　　判别栈是否为空。<br>　　例1.4&nbsp;StackApp.java使用了上面的各种方法。<br>　　例1.4&nbsp;StackApp.java。<br>　　import&nbsp;java.lang.</em>;<br>　　import&nbsp;java.util.<em>;<br>　　public&nbsp;class&nbsp;StackApp{<br>　　　public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[]){<br>　　　　Stack&nbsp;sta=new&nbsp;Stack();<br>　　　　sta.push(“Apple”);<br>　　　　sta.push(“banana”);<br>　　　　sta.push(“Cherry”);<br>　　　　//压入的为字符串对象<br>　　　　sta.push(new&nbsp;Integer(2));<br>　　　　//压入的为Integer的对象，值为2<br>　　　　sta.push(new&nbsp;Float(3.5));<br>　　　　//压入的为Float的对象，值为3.5<br>　　　　System.out.println(“The&nbsp;stack&nbsp;is,”+sta);<br>　　　　//对应栈sta<br>　　　　System.out.println(“The&nbsp;top&nbsp;of&nbsp;stack&nbsp;is:”+sta.peek());<br>　　　　//对应栈顶元素，但不将此元素弹出<br>　　　　System.out.println(“The&nbsp;position&nbsp;of&nbsp;object&nbsp;Cherry&nbsp;is:”<br>　　　　+sta.search(“cherry”));<br>　　　　//打印对象Cherry所处的位置<br>　　　　System.out.print(“Pop&nbsp;the&nbsp;element&nbsp;of&nbsp;the&nbsp;stack:”);<br>　　　　while(!sta.empty())<br>　　　　System.out.print(sta.pop()+”&nbsp;”);<br>　　　　System.out.println();<br>　　　　//将栈中的元素依次弹出并打印。与第一次打印的sta的结果比较，可看出栈<br>　　　　//先进后出的特点<br>　　　}<br>　　}<br>　　运行结果(略)<br><br><br>1.7&nbsp;哈希表类Hashtable<br><br>　<br>　哈希表是一种重要的存储方式，也是一种常见的检索方法。其基本思想是将关系码的值作为自变量，通过一定的函数关系计算出对应的函数值，把这个数值解释为<br>结点的存储地址，将结点存入计算得到存储地址所对应的存储单元。检索时采用检索关键码的方法。现在哈希表有一套完整的算法来进行插入、删除和解决冲突。在<br>Java中哈希表用于存储对象，实现快速检索。<br>　　Java.util.Hashtable提供了种方法让用户使用哈希表，而不需要考虑其哈希表真正如何工作。<br>　　哈希表类中提供了三种构造方法，分别是：<br>　　public&nbsp;Hashtable()<br>　　public&nbsp;Hashtable(int&nbsp;initialcapacity)<br>　　public&nbsp;Hashtable(int&nbsp;initialCapacity,float&nbsp;loadFactor)<br>　<br>　参数initialCapacity是Hashtable的初始容量，它的值应大于0。loadFactor又称装载因子，是一个0.0到0.1之间的<br>float型的浮点数。它是一个百分比，表明了哈希表何时需要扩充，例如，有一哈希表，容量为100，而装载因子为0.9，那么当哈希表90%的容量已被<br>使用时，此哈希表会自动扩充成一个更大的哈希表。如果用户不赋这些参数，系统会自动进行处理，而不需要用户操心。<br>　　Hashtable提供了基本的插入、检索等方法。<br>　　■插入<br>　　public&nbsp;synchronized&nbsp;void&nbsp;put(Object&nbsp;key,Object&nbsp;value)<br>给对象value设定一关键字key,并将其加到Hashtable中。若此关键字已经存在，则将此关键字对应的旧对象更新为新的对象Value。这表明在哈希表中相同的关键字不可能对应不同的对象(从哈希表的基本思想来看，这也是显而易见的)。<br>　　■检索<br>　　public&nbsp;synchronized&nbsp;Object&nbsp;get(Object&nbsp;key)<br>　　根据给定关键字key获取相对应的对象。<br>　　public&nbsp;synchronized&nbsp;boolean&nbsp;containsKey(Object&nbsp;key)<br>　　判断哈希表中是否包含关键字key。<br>　　public&nbsp;synchronized&nbsp;boolean&nbsp;contains(Object&nbsp;value)<br>　　判断value是否是哈希表中的一个元素。<br>　　■删除<br>　　public&nbsp;synchronized&nbsp;object&nbsp;remove(object&nbsp;key)<br>　　从哈希表中删除关键字key所对应的对象。<br>　　public&nbsp;synchronized&nbsp;void&nbsp;clear()<br>　　清除哈希表<br>　　另外，Hashtalbe还提供方法获取相对应的枚举集合：<br>　　public&nbsp;synchronized&nbsp;Enumeration&nbsp;keys()<br>　　返回关键字对应的枚举对象。<br>　　public&nbsp;synchronized&nbsp;Enumeration&nbsp;elements()<br>　　返回元素对应的枚举对象。<br>　　例1.5&nbsp;Hashtable.java给出了使用Hashtable的例子。<br>　　例1.5&nbsp;Hashtalbe.java。<br>　　//import&nbsp;java.lang.</em>;<br>　　import&nbsp;java.util.Hashtable;<br>　　import&nbsp;java.util.Enumeration;<br>　　public&nbsp;class&nbsp;HashApp{<br>　　　public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[]){<br>　　　　Hashtable&nbsp;hash=new&nbsp;Hashtable(2,(float)0.8);<br>　　　　//创建了一个哈希表的对象hash，初始容量为2，装载因子为0.8<br><br>　　　　hash.put(“Jiangsu”,”Nanjing”);<br>　　　　//将字符串对象“Jiangsu”给定一关键字“Nanjing”,并将它加入hash<br>　　　　hash.put(“Beijing”,”Beijing”);<br>　　　　hash.put(“Zhejiang”,”Hangzhou”);<br><br>　　　　System.out.println(“The&nbsp;hashtable&nbsp;hash1&nbsp;is:&nbsp;”+hash);<br>　　　　System.out.println(“The&nbsp;size&nbsp;of&nbsp;this&nbsp;hash&nbsp;table&nbsp;is&nbsp;”+hash.size());<br>　　　　//打印hash的内容和大小<br><br>　　　　Enumeration&nbsp;enum1=hash.elements();<br>　　　　System.out.print(“The&nbsp;element&nbsp;of&nbsp;hash&nbsp;is:&nbsp;”);<br>　　　　while(enum1.hasMoreElements())<br>　　　　　System.out.print(enum1.nextElement()+”&nbsp;”);<br>　　　　System.out.println();<br>　　　　//依次打印hash中的内容<br>　　　　if(hash.containsKey(“Jiangsu”))<br>　　　　　System.out.println(“The&nbsp;capatial&nbsp;of&nbsp;Jiangsu&nbsp;is&nbsp;”+hash.get(“Jiangsu”));<br>　　　　hash.remove(“Beijing”);<br>　　　　//删除关键字Beijing对应对象<br>　　　　System.out.println(“The&nbsp;hashtable&nbsp;hash2&nbsp;is:&nbsp;”+hash);<br>　　　　System.out.println(“The&nbsp;size&nbsp;of&nbsp;this&nbsp;hash&nbsp;table&nbsp;is&nbsp;”+hash.size());<br>　　　}<br>　　}<br><br>　　运行结果：<br>　　The&nbsp;hashtable&nbsp;hash1&nbsp;is:&nbsp;{Beijing=Beijing,&nbsp;Zhejiang=Hangzhou,&nbsp;Jiangsu=Nanjing}<br>　　The&nbsp;size&nbsp;of&nbsp;this&nbsp;hash&nbsp;table&nbsp;is&nbsp;3<br>　　The&nbsp;element&nbsp;of&nbsp;hash&nbsp;is:&nbsp;Beijing&nbsp;Hangzhou&nbsp;Nanjing<br>　　The&nbsp;capatial&nbsp;of&nbsp;Jiangsu&nbsp;is&nbsp;Nanjing<br>　　The&nbsp;hashtable&nbsp;hash2&nbsp;is:&nbsp;{Zhejiang=Hangzhou,&nbsp;Jiangsu=Nanjing}<br>　　The&nbsp;size&nbsp;of&nbsp;this&nbsp;hash&nbsp;table&nbsp;is&nbsp;2<br><br>　　Hashtable是Dictionary(字典)类的子类。在字典类中就把关键字对应到数据值。字典类是一个抽象类。在java.util中还有一个类Properties，它是Hashtable的子类。用它可以进行与对象属性相关的操作。<br><br>1.8&nbsp;位集合类BitSet<br><br>　　位集合类中封装了有关一组二进制数据的操作。<br>　　我们先来看一下例8.6&nbsp;BitSetApp.java。<br>　　例8.6&nbsp;BitSetApp.java<br>　　//import&nbsp;java.lang.*;<br>　　import&nbsp;java.util.BitSet;<br>　　public&nbsp;class&nbsp;BitSetApp{<br>　　　private&nbsp;static&nbsp;int&nbsp;n=5;<br>　　　public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args){<br>　　　　BitSet&nbsp;set1=new&nbsp;BitSet(n);<br>　　　　for(int&nbsp;i=0;i&lt;n;i++)&nbsp;set1.set(i);<br>　　　　//将set1的各位赋1，即各位均为true<br>　　　　BitSet&nbsp;set2=&nbsp;new&nbsp;BitSet();<br>　　　　set2=(BitSet)set1.clone();<br>　　　　//set2为set1的拷贝<br>　　　　set1.clear(0);<br>　　　　set2.clear(2);<br>　　　　//将set1的第0位set2的第2位清零<br>　　　　System.out.println(“The&nbsp;set1&nbsp;is:&nbsp;”+set1);<br>　　　　//直接将set1转换成字符串输出，输出的内容是set1中值true所处的位置<br>　　　　//打印结果为The&nbsp;set1&nbsp;is:{1,2,3,4}<br>　　　　System.out.println(“The&nbsp;hash&nbsp;code&nbsp;of&nbsp;set2&nbsp;is:&nbsp;”+set2.hashCode());<br>　　　　//打印set2的hashCode<br>　　　　printbit(“set1”,set1);<br>　　　　printbit(“set2”,set2);<br>　　　　//调用打印程序printbit(),打印对象中的每一个元素<br>　　　　//打印set1的结果为The&nbsp;bit&nbsp;set1&nbsp;is:&nbsp;false&nbsp;true&nbsp;true&nbsp;true&nbsp;true<br>　　　　set1.and(set2);<br>　　　　printbit(“set1&nbsp;and&nbsp;set2”,set1);<br>　　　　//完成set1&nbsp;and&nbsp;set2,并打印结果<br>　　　　set1.or(set2);<br>　　　　printbit(“set1&nbsp;or&nbsp;set2”,set1);<br>　　　　//完成set1&nbsp;or&nbsp;set2,并打印结果<br>　　　　set1.xor(set2);<br>　　　　printbit(“set1&nbsp;xor&nbsp;set2”,set1);<br>　　　　//完成set1&nbsp;xor&nbsp;set2,并打印结果<br>　　　}<br>　　　//打印BitSet对象中的内容<br>　　　public&nbsp;static&nbsp;void&nbsp;printbit(String&nbsp;name,BitSet&nbsp;set){<br>　　　　System.out.print(“The&nbsp;bit&nbsp;”+name+”&nbsp;is:&nbsp;”);<br>　　　　for(int&nbsp;i=0;i&lt;n;i++)<br>　　　　　System.out.print(set.get(i)+”&nbsp;”);<br>　　　　System.out.println();<br>　　　}<br>　　}<br><br>　　运行结果：<br>　　The&nbsp;set1&nbsp;is:&nbsp;{1,&nbsp;2,&nbsp;3,&nbsp;4}<br>　　The&nbsp;hash&nbsp;code&nbsp;of&nbsp;set2&nbsp;is:&nbsp;1225<br>　　The&nbsp;bit&nbsp;set1&nbsp;is:&nbsp;false&nbsp;true&nbsp;true&nbsp;true&nbsp;true<br>　　The&nbsp;bit&nbsp;set2&nbsp;is:&nbsp;true&nbsp;true&nbsp;false&nbsp;true&nbsp;true<br>　　The&nbsp;bit&nbsp;set1&nbsp;and&nbsp;set2&nbsp;is:&nbsp;false&nbsp;true&nbsp;false&nbsp;true&nbsp;true<br>　　The&nbsp;bit&nbsp;set1&nbsp;or&nbsp;set2&nbsp;is:&nbsp;true&nbsp;true&nbsp;false&nbsp;true&nbsp;true<br>　　The&nbsp;bit&nbsp;set1&nbsp;xor&nbsp;set2&nbsp;is:&nbsp;false&nbsp;false&nbsp;false&nbsp;false&nbsp;false<br><br>　　程序中使用了BitSet类提供的两种构造方法：<br>　　　　public&nbsp;BitSet();<br>　　　　public&nbsp;BitSet(int&nbsp;n);<br>　　参数n代表所创建的BitSet类的对象的大小。BitSet类的对象的大小在必要时会由系统自动扩充。<br>　　其它方法：<br>　　public&nbsp;void&nbsp;set(int&nbsp;n)<br>　　将BitSet对象的第n位设置成1。<br>　　public&nbsp;void&nbsp;clear(int&nbsp;n)<br>　　将BitSet对象的第n位清零。<br>　　public&nbsp;boolean&nbsp;get(int&nbsp;n)<br>　　读取位集合对象的第n位的值，它获取的是一个布尔值。当第n位为1时，返回true；第n位为0时，返回false。<br>　　另外，如在程序中所示，当把一BitSet类的对象转换成字符串输出时，输出的内容是此对象中true所处的位置。<br>　　在BitSet中提供了一组位操作，分别是：<br>　　public&nbsp;void&nbsp;and(BitSet&nbsp;set)<br>　　public&nbsp;void&nbsp;or(BitSet&nbsp;set)<br>　　public&nbsp;void&nbsp;xor(BitSet&nbsp;set)<br>利用它们可以完成两个位集合之间的与、或、异或操作。<br>　　BitSet类中有一方法public&nbsp;int&nbsp;size()来取得位集合的大小，它的返回值与初始化时设定的位集合大小n不一样，一般为64。<br><br>小结<br><br>　　本章我们介绍了Java的实用工具类库java.util中一些常用的类。java.util包中还有其它一些类。它们的具体用法用户可以自行查阅API。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/blog/tags/Java/" rel="tag"># Java</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/blog/cjcuko57p00up4urqa8av5dxd/" rel="next" title="java.lang包概述(6)">
                <i class="fa fa-chevron-left"></i> java.lang包概述(6)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/blog/cjcuko53s00or4urqg41dqp3v/" rel="prev" title="SSI">
                SSI <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Vanessa</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/blog/archives/">
              
                  <span class="site-state-item-count">874</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">224</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Vanessa</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/blog/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/blog/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/blog/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/blog/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/blog/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/blog/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
